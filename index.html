<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kaspa-Style BlockDAG</title>

  <!-- Preload Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    /* ──────────────────────────────────────────────────────────────────────────
       Base Styles & Theme
    ────────────────────────────────────────────────────────────────────────── */
    html,
    body {
      margin: 0;
      padding: 0;
      background: #0A051E;
      /* Fallback solid color */
      background: radial-gradient(ellipse at center, #1A103C 0%, #0A051E 70%, #0A051E 100%);
      font-family: 'Exo 2', sans-serif;
      color: #E0E0E0;
      overflow-x: hidden;
      overflow-y: auto;
    }

    svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Grid lines for background */
    .grid-line-minor {
      stroke: #1A103C;
      stroke-width: 0.3;
    }

    .grid-line-major {
      stroke: #2C1A4C;
      stroke-width: 0.6;
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Responsive Title Text
    ────────────────────────────────────────────────────────────────────────── */
    .title-text {
      font-family: 'Exo 2', sans-serif;
      font-weight: bold;
      fill: #00CFE0;
      opacity: 0.6;
      pointer-events: none;
      font-size: clamp(16px, 8vw, 40px);
      filter: drop-shadow(0px 0px 3px rgba(0, 207, 224, 0.3));
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Enhanced Node Styles & Animations
    ────────────────────────────────────────────────────────────────────────── */
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.15);
        opacity: 0.8;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .node-group rect {
      rx: 2;
      ry: 2;
      /* Rounded corners */
      stroke: rgba(170, 220, 255, 0.2);
      /* Subtle outline */
      stroke-width: 0.5px;
      /* Fill is assigned via JS using gradients */
    }

    .tip-node rect {
      stroke: #FFD700;
      /* Gold outline */
      stroke-width: 1.2px;
      /* Slightly thicker */
    }

    .node-group.selected-node rect {
      stroke: #00FFAA;
      stroke-width: 2px;
      filter: drop-shadow(0 0 5px #00FFAA);
    }

    .node-group.connected-node rect {
      stroke: #80FFDD;
      stroke-width: 1px;
    }

    .node-group.dimmed-node {
      opacity: 0.3;
    }

    /* Block label text (appears on hover/show-text toggle) */
    .block-label-text {
      fill: #E0E0E0;
      font-size: 9px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    /* When .show-text class is set on SVG, labels become visible */
    .show-text .block-label-text {
      opacity: 1;
    }


    /* ──────────────────────────────────────────────────────────────────────────
       Enhanced Link (Edge) Styles
    ────────────────────────────────────────────────────────────────────────── */
    .link {
      stroke: #70A0D0;
      stroke-opacity: 0.7;
      stroke-width: 1.5px;
      fill: none;
      stroke-linecap: round;
      transition: stroke-opacity 0.3s, stroke-width 0.3s, stroke 0.3s;
      /* Smooth transitions for highlighting */
    }

    .link.highlighted-link {
      stroke: #00CFE0;
      /* Brighter for highlight */
      stroke-opacity: 1;
      stroke-width: 2.5px;
    }

    .link.dimmed-link {
      stroke-opacity: 0.15;
    }

    /* Removed @keyframes dashFlow and .link-flow-active */

    /* ──────────────────────────────────────────────────────────────────────────
       Tooltip Style (Single shared tooltip)
    ────────────────────────────────────────────────────────────────────────── */
    .tooltip-text {
      font-family: 'Exo 2', sans-serif;
      font-size: 10px;
      fill: #F0F0F0;
      text-anchor: middle;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s linear;
      /* Basic background for readability */
      paint-order: stroke;
      stroke: rgba(10, 5, 30, 0.8);
      /* Match HUD bg for consistency */
      stroke-width: 6px;
      /* Creates padding */
      stroke-linejoin: round;
    }

    .tooltip-text tspan {
      text-anchor: middle;
    }


    /* ──────────────────────────────────────────────────────────────────────────
       Ambient Effects
    ────────────────────────────────────────────────────────────────────────── */
    .shooting-star {
      fill: rgba(200, 220, 255, 0.8);
      filter: blur(1px);
      pointer-events: none;
    }

    .new-column-beacon {
      stroke-width: 3px;
      stroke-linecap: round;
      pointer-events: none;
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Heads-Up Display (HUD)
    ────────────────────────────────────────────────────────────────────────── */
    #hud {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background-color: rgba(10, 5, 30, 0.85);
      border-top: 1px solid rgba(44, 26, 76, 0.7);
      padding: 8px 12px;
      font-size: 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      z-index: 100;
      color: #B0B0D0;
    }

    #hud>div,
    #hud>span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #hud label,
    #hud input,
    #hud button,
    #hud span {
      margin: 0;
      vertical-align: middle;
      font-family: 'Exo 2', sans-serif;
      color: #D0D0F0;
    }

    #hud input,
    #hud button {
      background-color: rgba(30, 20, 60, 0.7);
      border: 1px solid rgba(70, 50, 110, 0.8);
      color: #E0E0F0;
      border-radius: 3px;
      padding: 4px 6px;
    }

    #hud input[type="number"] {
      width: 48px;
      padding: 4px;
    }

    #hud input[type="checkbox"] {
      margin-left: 4px;
      accent-color: #00CFE0;
    }

    #hud button {
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s;
    }

    #hud button:hover {
      background-color: rgba(50, 40, 80, 0.9);
      border-color: #00CFE0;
    }

    /* Reset button with distinctive style */
    #resetBtn {
      padding: 6px 10px;
      background-color: #C03030;
      color: #fff;
      border: 1px solid #A02020;
    }

    #resetBtn:hover {
      background-color: #E04040;
      border-color: #FF6060;
    }

    /* Pause button styles */
    #hud button#pauseBtn {
      padding: 6px 10px;
      background-color: #4060C0;
      /* A different color */
      color: #fff;
      border: 1px solid #3040A0;
    }

    #hud button#pauseBtn:hover {
      background-color: #5070E0;
      border-color: #7090FF;
    }

    #hud button#pauseBtn.paused {
      background-color: #C08030;
      /* Orange when paused */
      border: 1px solid #A06020;
    }

    #hud button#pauseBtn.paused:hover {
      background-color: #E09040;
      border-color: #FFA060;
    }

    /* Responsive HUD tweaks for small screens */
    @media (max-width: 480px) {
      #hud {
        padding: 6px 8px;
        font-size: 11px;
        gap: 8px;
      }

      #hud input[type="number"] {
        width: 40px;
      }

      #hud>div,
      #hud>span {
        gap: 4px;
      }
    }
  </style>
</head>

<body>
  <!-- ──────────────────────────────────────────────────────────────────────────
       Heads-Up Display (HUD) Controls
  ────────────────────────────────────────────────────────────────────────── -->
  <div id="hud">
    <div>
      <label for="targetBPSInput">Target BPS:</label>
      <input type="number" id="targetBPSInput" value="10" min="1" max="500" step="1" />
    </div>
    <span>Realtime BPS: <span id="realtimeBPSDisplay">0.0</span></span>
    <div>
      <label>Zoom:</label>
      <button id="zoomOutBtn">−</button>
      <span id="zoomLevelDisplay">1.00x</span>
      <button id="zoomInBtn">+</button>
    </div>
    <div>
      <input type="checkbox" id="showTextToggle" checked />
      <label for="showTextToggle">Show Text</label>
    </div>
    <div>
      <input type="checkbox" id="showConnectionsToggle" checked />
      <label for="showConnectionsToggle">Show Connections</label>
    </div>
    <div>
      <label for="maxGenBackInput">Max Gens Back:</label>
      <input type="number" id="maxGenBackInput" value="5" min="1" max="10" />
    </div>
    <div>
      <label for="countBackInput">Count Back:</label>
      <input type="number" id="countBackInput" value="9" min="1" max="20" />
    </div>
    <div>
      <label for="maxParentsInput">Max Parents:</label>
      <input type="number" id="maxParentsInput" value="3" min="1" max="10" />
    </div>
    <button id="resetBtn">Reset</button>
    <button id="pauseBtn">Pause</button>
  </div>

  <!-- SVG container for D3-rendered BlockDAG -->
  <svg id="dagSvg" preserveAspectRatio="xMidYMid meet" viewBox="0 0 1000 700"></svg>

  <!-- Load D3.js (version 7) -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    (function () {
      /* ──────────────────────────────────────────────────────────────────────────
         1) Dimensions & Pan/Zoom State
      ────────────────────────────────────────────────────────────────────────── */
      let W = window.innerWidth;
      let H = window.innerHeight;
      let halfH = H / 2;
      const HORIZONTAL_SPACING = 100;

      let scrollX = W / 2;
      let currentZoom = 1.0;
      let isPaused = false;
      let latestBaseX = W / 2;
      let nextX = W / 2;

      let selectedNodeId = null; // For click interaction
      // Removed activeFlowTimeouts and LINK_FLOW_DURATION

      // For tip pulsing
      let tipPulseTimer;
      const TIP_PULSE_INTERVAL = 2100; // slightly > animation duration

      /* ──────────────────────────────────────────────────────────────────────────
         BPS & Burst Timing Constants
      ────────────────────────────────────────────────────────────────────────── */
      const DEFAULT_TARGET_BPS = 10;
      let TARGET_AVG_BPS = DEFAULT_TARGET_BPS;
      const BURST_FLUCT_PERCENT = 0.3;
      const MIN_INTERVAL_MS = 100;
      const MAX_INTERVAL_MS = 5000;
      const MIN_COLUMN_PERCENT = 0.20;
      const MAX_COLUMN_PERCENT = 0.80;

      const REFERENCE_UPPER_MAX_COLUMN_PERCENT = 0.90;
      const REFERENCE_LOWER_MAX_COLUMN_PERCENT = 0.40;
      const MIN_SPREAD_RATIO = 0.25;
      const MAX_SPREAD_RATIO = 1.0;
      let normalizedMCP = (MAX_COLUMN_PERCENT - REFERENCE_LOWER_MAX_COLUMN_PERCENT) /
        (REFERENCE_UPPER_MAX_COLUMN_PERCENT - REFERENCE_LOWER_MAX_COLUMN_PERCENT);
      normalizedMCP = Math.max(0, Math.min(1, normalizedMCP));
      const DYNAMIC_VERTICAL_SPREAD_RATIO = MIN_SPREAD_RATIO +
        normalizedMCP * (MAX_SPREAD_RATIO - MIN_SPREAD_RATIO);

      let MAX_GENERATIONS_BACK = 5;
      let COUNT_BACK = 9;
      let MAX_PARENTS_PER_BLOCK = 3;

      const BLOCK_W = 8, BLOCK_H = 8;
      const halfBlockW = BLOCK_W / 2, halfBlockH = BLOCK_H / 2;
      const MIN_SEP = 3;
      const VERTICAL_MARGIN = 10;
      const MIN_VERTICAL_CENTER_SPACING = BLOCK_H + MIN_SEP * 2;
      const PREFERRED_MAX_BLOCK_CENTER_SPACING_Y = BLOCK_H * 4.0;

      const RECENT_POOL = 12;
      const MAX_X_JITTER = 4;
      const MAX_Y_JITTER = 12;
      const COLLISION_ITERS = 50;
      const COLLISION_STEP = 0.5;
      const CHECK_W = BLOCK_W + MIN_SEP;
      const CHECK_H = BLOCK_H + MIN_SEP;
      const MAX_BURST_JITTER = 200;

      // Animation Durations
      const DURATION_NODE_ENTRY = 750;
      const DURATION_LINK_ENTRY = 750;
      const DURATION_MOVED_NODE_REPOSITION = 600;

      let nodes = [];
      let links = [];
      let nodeCounter = 0;
      const columnMap = new Map();
      let tipSet = new Set();

      let blockQueue = [];
      let blocksInWindow = 0;
      const BPS_WINDOW = 3000;

      const levelColors = ["#00CFE0", "#20B8D0", "#40A0C0", "#6088B0", "#8070A0"];

      /* ──────────────────────────────────────────────────────────────────────────
         2) Create SVG Elements & Definitions
      ────────────────────────────────────────────────────────────────────────── */
      const svg = d3.select("#dagSvg").attr("viewBox", `0 0 ${W} ${H}`);
      const g = svg.append("g");
      const defs = svg.append("defs");

      function defineGradient(id, color1, color2, opacity1 = 1, opacity2 = 1) {
        const gradient = defs.append("linearGradient")
          .attr("id", id)
          .attr("x1", "0%").attr("y1", "0%")
          .attr("x2", "0%").attr("y2", "100%");
        gradient.append("stop")
          .attr("offset", "0%")
          .style("stop-color", color1)
          .style("stop-opacity", opacity1);
        gradient.append("stop")
          .attr("offset", "100%")
          .style("stop-color", color2)
          .style("stop-opacity", opacity2);
      }

      defineGradient("blockGradientDefault", "#50E0F0", "#00A0B0");
      defineGradient("blockGradientTip", "#FFFFA0", "#FFD700", 1, 0.8);
      defineGradient("blockGradientSelected", "#00FFAA", "#00CC88");
      defineGradient("blockGradientConnected", "#A0FFEE", "#60DDC8");

      levelColors.forEach((color, i) => {
        const brighter = d3.color(color).brighter(0.5).formatHex();
        const darker = d3.color(color).darker(0.3).formatHex();
        defineGradient(`levelGradient${i}`, brighter, darker);
      });

      const beaconGradient = defs.append("linearGradient")
        .attr("id", "beaconGradient")
        .attr("x1", "0%").attr("y1", "0%")
        .attr("x2", "0%").attr("y2", "100%");
      beaconGradient.append("stop").attr("offset", "0%").style("stop-color", "#00CFE0").style("stop-opacity", 0);
      beaconGradient.append("stop").attr("offset", "50%").style("stop-color", "#00CFE0").style("stop-opacity", 0.8);
      beaconGradient.append("stop").attr("offset", "100%").style("stop-color", "#00CFE0").style("stop-opacity", 0);

      const GRID_SMALL = 20;
      const GRID_LARGE_INT = 5;
      const GRID_LARGE = GRID_SMALL * GRID_LARGE_INT;
      const gridPattern = defs.append("pattern")
        .attr("id", "gridPattern")
        .attr("width", GRID_LARGE)
        .attr("height", GRID_LARGE)
        .attr("patternUnits", "userSpaceOnUse");
      for (let i = 1; i < GRID_LARGE_INT; i++) {
        const pos = i * GRID_SMALL;
        gridPattern.append("line").attr("x1", pos).attr("y1", 0).attr("x2", pos).attr("y2", GRID_LARGE).attr("class", "grid-line-minor");
        gridPattern.append("line").attr("x1", 0).attr("y1", pos).attr("x2", GRID_LARGE).attr("y2", pos).attr("class", "grid-line-minor");
      }
      gridPattern.append("path").attr("d", `M 0 0 L ${GRID_LARGE} 0`).attr("class", "grid-line-major");
      gridPattern.append("path").attr("d", `M 0 0 L 0 ${GRID_LARGE}`).attr("class", "grid-line-major");
      let gridRect = g.append("rect").attr("fill", "url(#gridPattern)");

      const titleText = svg.append("text")
        .attr("class", "title-text")
        .attr("x", W / 2).attr("y", Math.max(20, H / 25))
        .attr("text-anchor", "middle").attr("dominant-baseline", "central")
        .text("BLOCKDAG SIM");

      const effectsG = g.append("g").attr("id", "effectsGroup");
      const linkG = g.append("g").attr("id", "linkGroup");
      const nodeG = g.append("g").attr("id", "nodeGroup");
      const tooltipG = g.append("g").attr("id", "tooltipGroup").style("pointer-events", "none");
      const singleTooltip = tooltipG.append("text").attr("class", "tooltip-text").attr("dy", "-0.5em");

      svg.on("click", function (event) {
        if (event.target === svg.node() || event.target === g.node() || event.target === gridRect.node()) {
          clearSelection();
        }
      });

      /* ──────────────────────────────────────────────────────────────────────────
         3) Helper Functions
      ────────────────────────────────────────────────────────────────────────── */
      function updateGridExtent() {
        if (currentZoom <= 0) return;
        const gridX = scrollX - (W / (2 * currentZoom));
        const gridY = halfH - (H / (2 * currentZoom));
        const gridWidth = W / currentZoom;
        const gridHeight = H / currentZoom;
        gridRect.attr("x", gridX).attr("y", gridY).attr("width", gridWidth).attr("height", gridHeight);
      }
      function clamp(v, min, max) { return v < min ? min : (v > max ? max : v); }
      function randBetween(min, max) { return Math.random() * (max - min) + min; }
      function randomJitter(amount) { return randBetween(-amount, amount); }
      function linkPath(sx, sy, tx, ty) {
        const midX = (sx + tx) / 2;
        return `M${sx},${sy}C${midX},${sy},${midX},${ty},${tx},${ty}`;
      }
      function computeLinkPath(d) { return linkPath(d.source.x, d.source.y, d.target.x, d.target.y); }
      function getRecentNodes() { return nodes.slice(-RECENT_POOL); }


      function clearSelection() {
        selectedNodeId = null;
        nodeG.selectAll("g.node-group")
          .classed("selected-node", false)
          .classed("connected-node", false)
          .classed("dimmed-node", false)
          .select("rect")
          .attr("fill", d => {
            const isTip = tipSet.has(d);
            return isTip ? "url(#blockGradientTip)" : `url(#levelGradient${d.level % levelColors.length})`;
          });
        linkG.selectAll("path.link")
          .classed("highlighted-link", false)
          .classed("dimmed-link", false);
      }

      function applySelectionStyles(clickedNode) {
        selectedNodeId = clickedNode.id;
        const connectedLinkIds = new Set();
        const connectedNodeIds = new Set([clickedNode.id]);

        links.forEach(link => {
          if (link.source.id === clickedNode.id || link.target.id === clickedNode.id) {
            connectedLinkIds.add(`${link.source.id}-${link.target.id}`);
            connectedNodeIds.add(link.source.id);
            connectedNodeIds.add(link.target.id);
          }
        });

        nodeG.selectAll("g.node-group")
          .classed("selected-node", d => d.id === clickedNode.id)
          .classed("connected-node", d => d.id !== clickedNode.id && connectedNodeIds.has(d.id))
          .classed("dimmed-node", d => !connectedNodeIds.has(d.id))
          .select("rect")
          .attr("fill", d => {
            if (d.id === clickedNode.id) return "url(#blockGradientSelected)";
            if (connectedNodeIds.has(d.id)) return "url(#blockGradientConnected)";
            const isTip = tipSet.has(d);
            return isTip ? "url(#blockGradientTip)" : `url(#levelGradient${d.level % levelColors.length})`;
          });

        linkG.selectAll("path.link")
          .classed("highlighted-link", d => connectedLinkIds.has(`${d.source.id}-${d.target.id}`))
          .classed("dimmed-link", d => !connectedLinkIds.has(`${d.source.id}-${d.target.id}`));
      }


      function updateNodeVisuals() {
        if (selectedNodeId) {
          const selNode = nodes.find(n => n.id === selectedNodeId);
          if (selNode) applySelectionStyles(selNode);
          else clearSelection();
          return;
        }

        nodeG.selectAll("g.node-group")
          .each(function (d) {
            const nodeElement = d3.select(this);
            const isTip = tipSet.has(d);
            nodeElement.classed("tip-node", isTip);
            let fillStyle = `url(#levelGradient${d.level % levelColors.length})`;
            if (isTip) {
              fillStyle = "url(#blockGradientTip)";
            }
            nodeElement.select("rect").attr("fill", fillStyle);
          });
        if (!isPaused) startTipPulsing(); else stopTipPulsing();
      }


      function startTipPulsing() {
        if (isPaused) return;
        stopTipPulsing();
        function pulseTips() {
          if (isPaused) { stopTipPulsing(); return; }
          nodeG.selectAll("g.tip-node rect")
            .style("animation", "none");
          requestAnimationFrame(() => {
            if (isPaused) { stopTipPulsing(); return; }
            nodeG.selectAll("g.tip-node rect")
              .style("animation", "pulse 2s ease-in-out infinite");
          });
          tipPulseTimer = setTimeout(pulseTips, TIP_PULSE_INTERVAL);
        }
        pulseTips();
      }

      function stopTipPulsing() {
        clearTimeout(tipPulseTimer);
        nodeG.selectAll("g.tip-node rect").style("animation", "none");
      }

      function attachParents(newNode) {
        const chosenParents = new Set();
        if (tipSet.size > 0) {
          const availableTips = Array.from(tipSet);
          d3.shuffle(availableTips);
          if (availableTips.length > 0) chosenParents.add(availableTips.pop());

          const recentNonTipPoolSize = Math.max(10, TARGET_AVG_BPS * 2);
          const recentNodesArr = nodes.slice(-recentNonTipPoolSize);
          const recentNonTips = recentNodesArr.filter(n => n.id !== newNode.id && !tipSet.has(n) && !chosenParents.has(n));
          const numToConsider = Math.min(3, Math.floor(MAX_PARENTS_PER_BLOCK / 2));
          const shuffledNonTips = d3.shuffle(recentNonTips).slice(0, numToConsider);
          let remainingCandidates = availableTips.concat(shuffledNonTips);
          d3.shuffle(remainingCandidates);

          const maxAdd = MAX_PARENTS_PER_BLOCK - chosenParents.size;
          let added = 0;
          for (const candidate of remainingCandidates) {
            if (added >= maxAdd) break;
            if (candidate.id !== newNode.id && !chosenParents.has(candidate)) {
              chosenParents.add(candidate);
              added++;
            }
          }
        }
        chosenParents.forEach(parent => {
          links.push({ source: newNode, target: parent });
          tipSet.delete(parent);
        });
        tipSet.add(newNode);
      }

      function computeEvenYs(k) {
        if (k === 0) return [];
        const screenCenterY = H / 2;
        if (k === 1) return [screenCenterY];
        const fullSpan = Math.max(0, H - 2 * VERTICAL_MARGIN - BLOCK_H);
        const allowedSpan = fullSpan * DYNAMIC_VERTICAL_SPREAD_RATIO;
        let centerSpacing = allowedSpan / (k - 1);
        centerSpacing = clamp(centerSpacing, MIN_VERTICAL_CENTER_SPACING, PREFERRED_MAX_BLOCK_CENTER_SPACING_Y);
        const totalSpan = (k - 1) * centerSpacing;
        const firstY = screenCenterY - totalSpan / 2;
        return Array.from({ length: k }, (_, i) => firstY + i * centerSpacing);
      }

      function resolveCollisions(nodesInCol, centerX) {
        if (nodesInCol.length < 2) return;
        const xMin = centerX - MAX_X_JITTER;
        const xMax = centerX + MAX_X_JITTER;
        const yClampRange = H * 2;
        const yMinClamp = (H / 2) - yClampRange;
        const yMaxClamp = (H / 2) + yClampRange;

        for (let iter = 0; iter < COLLISION_ITERS; iter++) {
          let anyCollision = false;
          const qt = d3.quadtree().x(d => d.x).y(d => d.y).addAll(nodesInCol);
          nodesInCol.forEach(node => {
            const x0 = node.x - CHECK_W, y0 = node.y - CHECK_H, x1 = node.x + CHECK_W, y1 = node.y + CHECK_H;
            qt.visit((quad, x2, y2, x3, y3) => {
              if (x2 > x1 || y2 > y1 || x3 < x0 || y3 < y0) return true;
              if (!quad.length) {
                const other = quad.data;
                if (other !== node) {
                  const dx = node.x - other.x, dy = node.y - other.y;
                  if (Math.abs(dx) < CHECK_W && Math.abs(dy) < CHECK_H) {
                    anyCollision = true;
                    const dist = Math.hypot(dx, dy) || 1e-3;
                    const overlapX = (CHECK_W - Math.abs(dx)) / dist;
                    const overlapY = (CHECK_H - Math.abs(dy)) / dist;
                    node.x += dx * COLLISION_STEP * overlapX;
                    node.y += dy * COLLISION_STEP * overlapY;
                    other.x -= dx * COLLISION_STEP * overlapX;
                    other.y -= dy * COLLISION_STEP * overlapY;
                    node.x = clamp(node.x, xMin, xMax);
                    node.y = clamp(node.y, yMinClamp, yMaxClamp);
                    other.x = clamp(other.x, xMin, xMax);
                    other.y = clamp(other.y, yMinClamp, yMaxClamp);
                  }
                }
              }
              return false;
            });
          });
          if (!anyCollision) break;
        }
      }

      /* ──────────────────────────────────────────────────────────────────────────
         4) BPS (Blocks Per Second) Calculation & Pruning
      ────────────────────────────────────────────────────────────────────────── */
      function recordNewBlocks(count) {
        const ts = Date.now();
        blockQueue.push({ ts, count });
        blocksInWindow += count;
        pruneOldBlockQueue();
      }
      function pruneOldBlockQueue() {
        const cutoffTime = Date.now() - BPS_WINDOW;
        while (blockQueue.length && blockQueue[0].ts < cutoffTime) {
          blocksInWindow -= blockQueue[0].count;
          blockQueue.shift();
        }
      }
      function updateRealtimeBPS() {
        pruneOldBlockQueue();
        const currentBps = blocksInWindow / (BPS_WINDOW / 1000);
        document.getElementById("realtimeBPSDisplay").textContent = currentBps.toFixed(1);
      }
      setInterval(updateRealtimeBPS, 1000);

      function pruneOffscreen() {
        if (!nodes.length) return;
        const leftWorld = scrollX - (W / (2 * currentZoom));
        const cutoffX = leftWorld - (W / currentZoom);
        const survivors = nodes.filter(d => (d.x >= cutoffX) || (d.justMoved));

        if (survivors.length === nodes.length) return;

        const liveIds = new Set(survivors.map(n => n.id));
        nodes = survivors;
        links = links.filter(l => liveIds.has(l.source.id) && liveIds.has(l.target.id));
        const newTipSet = new Set();
        tipSet.forEach(tip => { if (liveIds.has(tip.id)) newTipSet.add(tip); });
        tipSet = newTipSet;

        nodeG.selectAll("g.node-group").filter(d => !liveIds.has(d.id)).remove();
        linkG.selectAll("path.link").filter(d => !liveIds.has(d.source.id) || !liveIds.has(d.target.id)).remove();

        if (selectedNodeId && !liveIds.has(selectedNodeId)) {
          clearSelection();
        }
        updateNodeVisuals();
      }

      /* ──────────────────────────────────────────────────────────────────────────
         5) addColumn - Generate a new column of blocks (with entry animations)
      ────────────────────────────────────────────────────────────────────────── */
      function addColumn(count) {
        if (count < 1) return;
        const doGenBack = Math.random() < 0.3;
        let level = 1;
        const levelSamplePool = nodes.slice(-RECENT_POOL * 2);
        if (levelSamplePool.length) {
          const pick = d3.shuffle(levelSamplePool.slice()).map(d => d.level || 1);
          level = Math.min(levelColors.length - 1, d3.max(pick) + 1);
        }

        const colX = nextX;
        latestBaseX = Math.max(latestBaseX, colX);
        nextX += HORIZONTAL_SPACING;
        if (!columnMap.has(colX)) columnMap.set(colX, []);
        let newBlocksAddedThisCall = 0;

        if (count > 0) {
          effectsG.append("line")
            .attr("class", "new-column-beacon")
            .attr("x1", colX).attr("y1", 0).attr("x2", colX).attr("y2", H)
            .attr("stroke", "url(#beaconGradient)")
            .style("opacity", 0.8)
            .transition().duration(1500).style("opacity", 0).remove();
        }

        function createBatch(numNew, xVal, targetYs, existingArr = [], isBackfill = false) {
          const batch = [];
          for (let i = 0; i < numNew; i++) {
            const node = {
              id: `B${nodeCounter++}`, columnX: xVal, level,
              x: xVal + randomJitter(MAX_X_JITTER),
              y: targetYs[i] + randomJitter(MAX_Y_JITTER)
            };
            attachParents(node);
            nodes.push(node);
            batch.push(node);
          }
          const combined = existingArr.concat(batch);
          resolveCollisions(combined, xVal);
          if (isBackfill) columnMap.set(xVal, combined);
          else columnMap.get(xVal).push(...batch);
          newBlocksAddedThisCall += batch.length;

          const nodeJoin = nodeG.selectAll("g.node-group").data(nodes, d => d.id);
          const enterSel = nodeJoin.enter()
            .filter(d => batch.some(nb => nb.id === d.id))
            .append("g")
            .attr("class", "node-group")
            .each(function (dNode) {
              const isNodeEffectivelyBackfilled = dNode.columnX < colX;
              if (isNodeEffectivelyBackfilled) {
                dNode.anim_initialVerticalOffset = (Math.random() - 0.5) * Math.min(80, H * 0.05);
                dNode.anim_initialY = dNode.y + dNode.anim_initialVerticalOffset;
                const originXForBackfill = dNode.columnX + HORIZONTAL_SPACING;
                const randomDirection = (Math.random() < 0.5 ? -1 : 1);
                dNode.anim_initialHorizontalOffset = randomDirection * (HORIZONTAL_SPACING * 0.05 + Math.random() * HORIZONTAL_SPACING * 0.1);
                dNode.anim_initialX = originXForBackfill + dNode.anim_initialHorizontalOffset;
              } else {
                dNode.anim_initialVerticalOffset = (Math.random() - 0.5) * Math.min(150, H * 0.15);
                dNode.anim_initialY = (H / 2) + dNode.anim_initialVerticalOffset;
                const randomDirection = (Math.random() < 0.5 ? -1 : 1);
                const horizontalOffsetMagnitude = (HORIZONTAL_SPACING * 0.25 + Math.random() * HORIZONTAL_SPACING * 0.35);
                dNode.anim_initialHorizontalOffset = randomDirection * horizontalOffsetMagnitude;
                dNode.anim_initialX = dNode.x + dNode.anim_initialHorizontalOffset;
              }
              dNode.anim_initialScale = 0.3;
              if (isNaN(dNode.anim_initialX) || isNaN(dNode.anim_initialY) || isNaN(dNode.anim_initialScale)) {
                console.error(`ERROR Node ${dNode.id}: NaN in initial animation properties!`);
                dNode.anim_initialX = dNode.x || (W / 2); dNode.anim_initialY = dNode.y || (H / 2); dNode.anim_initialScale = 1;
              }
            })
            .attr("transform", dNode => `translate(${dNode.anim_initialX}, ${dNode.anim_initialY}) scale(${dNode.anim_initialScale})`)
            .style("opacity", 0);

          enterSel.append("rect")
            .attr("x", -halfBlockW).attr("y", -halfBlockH)
            .attr("width", BLOCK_W).attr("height", BLOCK_H);

          enterSel.append("text")
            .attr("class", "block-label-text")
            .attr("dy", -halfBlockH - 4).attr("text-anchor", "middle")
            .text(dNode => dNode.id)
            .style("opacity", 0)
            .transition("textAppear").delay(dNode => randBetween(0, MAX_BURST_JITTER) + 350).duration(200)
            .style("opacity", showText ? 1 : 0);

          enterSel.on("mouseover", function (event, dNode) {
            if (selectedNodeId && d3.select(this).classed('dimmed-node')) return;
            const parentIds = links.filter(l => l.source.id === dNode.id).map(l => l.target.id.replace("B", ""));
            const childIds = links.filter(l => l.target.id === dNode.id).map(l => l.source.id.replace("B", ""));
            singleTooltip
              .attr("x", dNode.x).attr("y", dNode.y - halfBlockH - 8)
              .selectAll("tspan").data([
                `ID: ${dNode.id} | Lvl: ${dNode.level}`,
                `P: ${parentIds.length > 0 ? parentIds.slice(0, 3).join(',') + (parentIds.length > 3 ? '...' : '') : '0'} | C: ${childIds.length > 0 ? childIds.slice(0, 3).join(',') + (childIds.length > 3 ? '...' : '') : '0'}`
              ]).join("tspan")
              .attr("x", dNode.x).attr("dy", (d, i) => i === 0 ? 0 : "1.2em")
              .text(dText => dText);
            singleTooltip.style("opacity", 1);
          }).on("mouseout", function () {
            singleTooltip.style("opacity", 0);
          }).on("click", function (event, dNode) {
            event.stopPropagation();
            if (selectedNodeId === dNode.id) clearSelection();
            else { clearSelection(); applySelectionStyles(dNode); }
            updateNodeVisuals();
          });

          enterSel.transition("nodeEntry")
            .delay(dNode => randBetween(0, MAX_BURST_JITTER))
            .duration(DURATION_NODE_ENTRY)
            .attr("transform", dNode => `translate(${dNode.x}, ${dNode.y}) scale(1)`)
            .style("opacity", 1)
            .on("interrupt", function (dNode) { d3.select(this).attr("transform", `translate(${dNode.x}, ${dNode.y}) scale(1)`).style("opacity", 1); })
            .on("end", function (dNode) { d3.select(this).attr("transform", `translate(${dNode.x}, ${dNode.y}) scale(1)`).style("opacity", 1); });

          const newLinkData = links.filter(l => batch.some(nb => nb.id === l.source.id));
          const linkJoin = linkG.selectAll("path.link").data(links, d => `${d.source.id}-${d.target.id}`);
          const linkEnter = linkJoin.enter()
            .filter(d => newLinkData.some(nl => nl.source.id === d.source.id && nl.target.id === d.target.id))
            .append("path").attr("class", "link").style("opacity", 0);
          // Removed .classed("link-flow-active", true)

          linkEnter.each(function (dLink) {
            const linkElement = d3.select(this);
            const srcNode = dLink.source, tgtNode = dLink.target;
            if (isNaN(srcNode.anim_initialX) || isNaN(srcNode.anim_initialY) || isNaN(srcNode.x) || isNaN(srcNode.y) || isNaN(tgtNode.x) || isNaN(tgtNode.y)) {
              console.error(`ERROR Link Setup: NaN in coordinates for link ${srcNode.id}->${tgtNode.id}.`);
              linkElement.attr("d", computeLinkPath(dLink)).style("opacity", connectionsVisible ? 0.7 : 0); return;
            }
            const initialPath = linkPath(srcNode.anim_initialX, srcNode.anim_initialY, tgtNode.x, tgtNode.y);
            linkElement.attr("d", initialPath);
            linkElement.transition(`linkEntrySynced_${srcNode.id}_${tgtNode.id}`)
              .delay(0).duration(DURATION_LINK_ENTRY)
              .style("opacity", connectionsVisible ? 0.7 : 0)
              .attrTween("d", function () {
                const iSX = d3.interpolate(srcNode.anim_initialX, srcNode.x), iSY = d3.interpolate(srcNode.anim_initialY, srcNode.y);
                let sTX = tgtNode.x, sTY = tgtNode.y, iMTX = null, iMTY = null;
                if (tgtNode.isRepositioning && typeof tgtNode.oldX !== 'undefined' && typeof tgtNode.oldY !== 'undefined') {
                  iMTX = d3.interpolate(tgtNode.oldX, tgtNode.x); iMTY = d3.interpolate(tgtNode.oldY, tgtNode.y);
                }
                return function (t_link) {
                  const cSX = iSX(t_link), cSY = iSY(t_link); let cTX, cTY;
                  if (iMTX) {
                    const linkET = t_link * DURATION_LINK_ENTRY;
                    if (linkET < DURATION_MOVED_NODE_REPOSITION) {
                      const t_target = linkET / DURATION_MOVED_NODE_REPOSITION;
                      cTX = iMTX(t_target); cTY = iMTY(t_target);
                    } else { cTX = sTX; cTY = sTY; }
                  } else { cTX = sTX; cTY = sTY; }
                  if (isNaN(cSX) || isNaN(cSY) || isNaN(cTX) || isNaN(cTY)) { return linkElement.attr("d"); }
                  return linkPath(cSX, cSY, cTX, cTY);
                };
              })
              .on("interrupt", function () { d3.select(this).attr("d", computeLinkPath(dLink)).style("opacity", connectionsVisible ? 0.7 : 0); })
              .on("end", function () { d3.select(this).attr("d", computeLinkPath(dLink)).style("opacity", connectionsVisible ? 0.7 : 0); });

            // Removed timeout logic for link-flow-active
          });
          updateNodeVisuals();
          return batch;
        }

        if (!doGenBack) {
          const Ys = computeEvenYs(count); createBatch(count, colX, Ys);
        } else {
          let actualNew = 1, backfillCount = 0;
          if (count > COUNT_BACK) { actualNew = count - COUNT_BACK; backfillCount = COUNT_BACK; }
          else { actualNew = 1; backfillCount = count - 1; }
          if (actualNew > 0) { const YsNew = computeEvenYs(actualNew); createBatch(actualNew, colX, YsNew); }
          if (backfillCount > 0) {
            const backfillCols = Math.ceil(randBetween(1, MAX_GENERATIONS_BACK + 1));
            let backfillTargetX = colX - backfillCols * HORIZONTAL_SPACING;
            backfillTargetX = Math.max(0, backfillTargetX);
            if (!columnMap.has(backfillTargetX)) columnMap.set(backfillTargetX, []);
            const existingInBackfill = columnMap.get(backfillTargetX).slice();
            const newTotal = existingInBackfill.length + backfillCount;
            const YsBackfill = computeEvenYs(newTotal);
            existingInBackfill.forEach((n, i) => {
              n.oldX = n.x; n.oldY = n.y; n.isRepositioning = true;
              n.x = n.columnX + randomJitter(MAX_X_JITTER); n.y = YsBackfill[i] + randomJitter(MAX_Y_JITTER);
            });
            const newYs = YsBackfill.slice(existingInBackfill.length);
            createBatch(backfillCount, backfillTargetX, newYs, existingInBackfill, true);
            const movedIds = new Set(existingInBackfill.map(d => d.id));
            nodeG.selectAll("g.node-group").filter(d => movedIds.has(d.id))
              .transition("repositionExisting").duration(DURATION_MOVED_NODE_REPOSITION)
              .attr("transform", d => `translate(${d.x}, ${d.y})`).style("opacity", 1)
              .on("end", function (d) { d.isRepositioning = false; delete d.oldX; delete d.oldY; });
            linkG.selectAll("path.link").filter(dL => (movedIds.has(dL.source.id) && dL.source.columnX === backfillTargetX) || (movedIds.has(dL.target.id) && dL.target.columnX === backfillTargetX))
              .transition("repositionLinks").duration(600)
              .attrTween("d", function (dL) { const p = d3.select(this).attr("d"), f = computeLinkPath(dL); return d3.interpolateString(p, f); });
          }
        }
        if (newBlocksAddedThisCall > 0) recordNewBlocks(newBlocksAddedThisCall);
      }

      /* ──────────────────────────────────────────────────────────────────────────
         6) Scheduler: Determines when to add the next column of blocks
      ────────────────────────────────────────────────────────────────────────── */
      let nextBurstScheduler = performance.now();
      function computeNextInterval(currentTime) {
        const avgColSizePercent = (MIN_COLUMN_PERCENT + MAX_COLUMN_PERCENT) / 2;
        const maxBlocksAtAvg = Math.max(1, Math.floor(TARGET_AVG_BPS * avgColSizePercent));
        let avgBlocksPerBurst = (maxBlocksAtAvg + 1) / 2; avgBlocksPerBurst = Math.max(1, avgBlocksPerBurst);
        let targetBurstsPerSecond = TARGET_AVG_BPS / avgBlocksPerBurst; targetBurstsPerSecond = Math.max(targetBurstsPerSecond, 0.01);
        let avgInterval = 1000 / targetBurstsPerSecond; avgInterval = clamp(avgInterval, MIN_INTERVAL_MS, MAX_INTERVAL_MS);
        const fluctuation = avgInterval * BURST_FLUCT_PERCENT;
        let minInterval = Math.max(MIN_INTERVAL_MS, avgInterval - fluctuation);
        let maxInterval = Math.min(MAX_INTERVAL_MS, avgInterval + fluctuation);
        if (minInterval >= maxInterval) maxInterval = minInterval + MIN_INTERVAL_MS * 0.1;
        return currentTime + randBetween(minInterval, maxInterval);
      }

      d3.timer(() => {
        const currentTime = performance.now();
        if (!isPaused && TARGET_AVG_BPS > 0 && currentTime >= nextBurstScheduler) {
          const frac = randBetween(MIN_COLUMN_PERCENT, MAX_COLUMN_PERCENT);
          const maxThisRound = Math.max(1, Math.floor(TARGET_AVG_BPS * frac));
          const numBlocksInBurst = Math.floor(Math.random() * maxThisRound) + 1;
          try { addColumn(numBlocksInBurst); }
          catch (e) { console.error("Error during addColumn:", e); d3.select(this).stop(); return; }
          nextBurstScheduler = computeNextInterval(currentTime);
          if (isNaN(nextBurstScheduler)) { console.error("Scheduler error: nextBurstScheduler is NaN. Stopping."); d3.select(this).stop(); return; }
        }
      });

      /* ──────────────────────────────────────────────────────────────────────────
         Ambient Effects - Shooting Stars
      ────────────────────────────────────────────────────────────────────────── */
      function addShootingStar() {
        if (isPaused || currentZoom < 0.2 || Math.random() > 0.15) return;

        const starSize = randBetween(1, 3) / Math.sqrt(currentZoom);
        const duration = randBetween(1500, 4000);
        const worldWidth = W / currentZoom;
        const worldHeight = H / currentZoom;

        const startX = scrollX + (Math.random() > 0.5 ? -1 : 1) * (worldWidth / 2 + 50);
        const startY = halfH + randBetween(-worldHeight / 1.5, worldHeight / 1.5);

        const endX = scrollX + (startX > scrollX ? -1 : 1) * randBetween(worldWidth * 0.8, worldWidth * 1.5);
        const endY = halfH + randBetween(-worldHeight, worldHeight);

        effectsG.append("circle")
          .attr("class", "shooting-star")
          .attr("cx", startX).attr("cy", startY).attr("r", starSize)
          .style("opacity", 0.7)
          .transition().duration(duration).ease(d3.easeQuadIn)
          .attr("cx", endX).attr("cy", endY)
          .style("opacity", 0).remove();
      }
      d3.timer(addShootingStar, 300);

      /* ──────────────────────────────────────────────────────────────────────────
         7) D3 Zoom Behavior
      ────────────────────────────────────────────────────────────────────────── */
      const zoomBehavior = d3.zoom().scaleExtent([0.05, 10])
        .on("zoom", (event) => {
          currentZoom = event.transform.k;
          document.getElementById("zoomLevelDisplay").textContent = `${currentZoom.toFixed(2)}x`;
          const transform = `translate(${W / 2}, ${H / 2}) scale(${currentZoom}) translate(${-scrollX}, ${-halfH})`;
          g.attr("transform", transform);
          tooltipG.attr("transform", transform);
          updateGridExtent();
        });
      svg.call(zoomBehavior).on("dblclick.zoom", null);

      /* ──────────────────────────────────────────────────────────────────────────
         8) Auto-pan & Render Loop
      ────────────────────────────────────────────────────────────────────────── */
      d3.timer(() => {
        if (!isPaused) {
          const diff = latestBaseX - scrollX;
          scrollX += (Math.abs(diff) < 0.1 ? diff : diff * 0.05);
        }
        const transform = `translate(${W / 2}, ${H / 2}) scale(${currentZoom}) translate(${-scrollX}, ${-halfH})`;
        g.attr("transform", transform);
        tooltipG.attr("transform", transform);
        updateGridExtent();
        pruneOffscreen();
      });

      /* ──────────────────────────────────────────────────────────────────────────
         9) Responsive Resize Handler
      ────────────────────────────────────────────────────────────────────────── */
      function updateDimensions() {
        W = window.innerWidth; H = window.innerHeight; halfH = H / 2;
        svg.attr("viewBox", `0 0 ${W} ${H}`);
        const titleY = (W <= 480) ? Math.max(20, H / 20) : Math.max(20, H / 25);
        svg.select("text.title-text").attr("x", W / 2).attr("y", titleY);
        updateGridExtent();
      }
      window.addEventListener("resize", updateDimensions);

      /* ──────────────────────────────────────────────────────────────────────────
         10) HUD Elements & Event Listeners
      ────────────────────────────────────────────────────────────────────────── */
      const targetInput = document.getElementById("targetBPSInput");
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomDisplay = document.getElementById("zoomLevelDisplay");
      const resetBtn = document.getElementById("resetBtn");
      const showTextToggle = document.getElementById("showTextToggle");
      const showConnectionsToggle = document.getElementById("showConnectionsToggle");
      const maxGenBackInput = document.getElementById("maxGenBackInput");
      const countBackInput = document.getElementById("countBackInput");
      const maxParentsInput = document.getElementById("maxParentsInput");
      const pauseBtn = document.getElementById("pauseBtn");
      let showText = true;
      let connectionsVisible = true;

      targetInput.addEventListener("change", e => {
        const val = parseInt(e.target.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 1000) { TARGET_AVG_BPS = val; }
        else { e.target.value = TARGET_AVG_BPS; }
      });
      maxGenBackInput.addEventListener("change", e => {
        const v = parseInt(e.target.value, 10);
        if (!isNaN(v) && v >= 1 && v <= 10) MAX_GENERATIONS_BACK = v; else e.target.value = MAX_GENERATIONS_BACK;
      });
      maxParentsInput.value = MAX_PARENTS_PER_BLOCK;
      maxParentsInput.addEventListener("change", e => {
        const val = parseInt(e.target.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 10) MAX_PARENTS_PER_BLOCK = val; else e.target.value = MAX_PARENTS_PER_BLOCK;
      });
      countBackInput.addEventListener("change", e => {
        const v = parseInt(e.target.value, 10);
        if (!isNaN(v) && v >= 1 && v <= 20) COUNT_BACK = v; else e.target.value = COUNT_BACK;
      });
      zoomInBtn.addEventListener("click", () => { svg.transition().duration(300).call(zoomBehavior.scaleBy, 1.2); });
      zoomOutBtn.addEventListener("click", () => { svg.transition().duration(300).call(zoomBehavior.scaleBy, 1 / 1.2); });
      showTextToggle.addEventListener("change", e => {
        showText = e.target.checked; svg.classed("show-text", showText);
        svg.selectAll(".block-label-text").style("opacity", showText ? 1 : 0);
      });
      showConnectionsToggle.addEventListener("change", e => {
        connectionsVisible = e.target.checked;
        linkG.style("display", connectionsVisible ? null : "none");
        if (connectionsVisible) {
          linkG.selectAll("path.link").filter(function () { return !d3.select(this).classed("dimmed-link"); })
            .style("opacity", 0.7);
        }
      });
      pauseBtn.addEventListener("click", () => {
        isPaused = !isPaused;
        pauseBtn.textContent = isPaused ? "Resume" : "Pause";
        pauseBtn.classList.toggle("paused", isPaused);
        if (isPaused) {
          stopTipPulsing();
        } else {
          startTipPulsing();
          if (TARGET_AVG_BPS > 0 && nodes.length === 0) scheduleFirstColumn();
          nextBurstScheduler = performance.now() + 100;
        }
      });
      resetBtn.addEventListener("click", resetVis);

      function resetVis() {
        nodes = []; links = []; blockQueue = []; blocksInWindow = 0;
        columnMap.clear(); nodeCounter = 0; tipSet = new Set();
        scrollX = window.innerWidth / 2; currentZoom = 1.0;
        updateDimensions(); nextX = W / 2; latestBaseX = W / 2;

        nodeG.selectAll("g.node-group").remove();
        linkG.selectAll("path.link").remove();
        singleTooltip.style("opacity", 0);

        targetInput.value = TARGET_AVG_BPS = DEFAULT_TARGET_BPS;
        document.getElementById("realtimeBPSDisplay").textContent = "0.0";
        zoomDisplay.textContent = `${currentZoom.toFixed(2)}x`;
        showTextToggle.checked = true; showText = true; svg.classed("show-text", true);
        svg.selectAll(".block-label-text").style("opacity", 1);
        showConnectionsToggle.checked = true; connectionsVisible = true; linkG.style("display", null);
        maxGenBackInput.value = MAX_GENERATIONS_BACK = 5;
        countBackInput.value = COUNT_BACK = 9;
        maxParentsInput.value = MAX_PARENTS_PER_BLOCK = 3;

        clearSelection();
        stopTipPulsing();
        // Removed activeFlowTimeouts clearing
        effectsG.selectAll("*").remove();

        isPaused = false;
        pauseBtn.textContent = "Pause";
        pauseBtn.classList.remove("paused");

        const transform = `translate(${W / 2}, ${H / 2}) scale(${currentZoom}) translate(${-scrollX}, ${-halfH})`;
        g.attr("transform", transform); tooltipG.attr("transform", transform);

        scheduleFirstColumn();
        if (!isPaused) startTipPulsing();
      }

      /* ──────────────────────────────────────────────────────────────────────────
         11) Initial Setup & Start
      ────────────────────────────────────────────────────────────────────────── */
      function scheduleFirstColumn() {
        if (nodes.length > 0) return;
        const initialCount = Math.max(1, Math.floor(TARGET_AVG_BPS * MIN_COLUMN_PERCENT));
        addColumn(initialCount);
        nextBurstScheduler = performance.now() + 1;
      }
      updateDimensions();
      zoomDisplay.textContent = `${currentZoom.toFixed(2)}x`;
      svg.classed("show-text", showText);
      scheduleFirstColumn();
      if (!isPaused) startTipPulsing();
    })();
  </script>
</body>

</html>
