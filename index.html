<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kaspa‐Style BlockDAG (Responsive Title)</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #111;
      font-family: sans-serif;
      color: #fff;
      overflow-x: hidden;
      overflow-y: auto;
    }

    svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ───── Responsive Title ────────────────────────────────────────────────── */
    .title-text {
      font-family: sans-serif;
      font-weight: bold;
      fill: #ff0000;
      opacity: 0.5;
      pointer-events: none;

      /* clamp(min, ideal, max) → min=16px, ideal=8vw, max=40px */
      font-size: clamp(16px, 8vw, 40px);
    }

    .link {
      stroke: #999;
      stroke-opacity: 0.6;
      fill: none;
    }

    .block-label-text {
      fill: #fff;
      font-size: 9px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .show-text .block-label-text {
      opacity: 1;
    }

    #hud {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      font-size: 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      z-index: 100;
      border-radius: 0;
    }

    #hud>div,
    #hud>span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #hud label,
    #hud input,
    #hud button,
    #hud span {
      margin: 0;
      vertical-align: middle;
    }

    #hud input[type="number"] {
      width: 48px;
    }

    #hud input[type="checkbox"] {
      margin-left: 4px;
    }

    #resetBtn {
      padding: 6px 10px;
      background-color: #555;
      color: white;
      border: 1px solid #777;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    #resetBtn:hover {
      background-color: #666;
    }

    #hud button {
      padding: 4px 8px;
      font-size: 12px;
    }

    @media (max-width: 480px) {
      #hud {
        padding: 6px 8px;
        font-size: 11px;
        gap: 8px;
      }

      #hud input[type="number"] {
        width: 40px;
      }

      #hud>div,
      #hud>span {
        gap: 4px;
      }
    }
  </style>
</head>

<body>
  <!--────────────────────────────────────────────────────────────────────────
    HUD (controls) pinned to the bottom, full width
  ──────────────────────────────────────────────────────────────────────────-->
  <div id="hud">
    <div>
      <label for="targetBPSInput">Target BPS:</label>
      <input type="number" id="targetBPSInput" value="10" min="1" max="500" step="1">
    </div>
    <span>
      Realtime BPS: <span id="realtimeBPSDisplay">0.0</span>
    </span>
    <div>
      <label>Zoom:</label>
      <button id="zoomOutBtn">−</button>
      <span id="zoomLevelDisplay">1.00x</span>
      <button id="zoomInBtn">+</button>
    </div>
    <div>
      <input type="checkbox" id="showTextToggle" checked>
      <label for="showTextToggle">Show Text</label>
    </div>
    <div>
      <input type="checkbox" id="showConnectionsToggle" checked>
      <label for="showConnectionsToggle">Show Connections</label>
    </div>
    <div>
      <label for="maxGenBackInput">Max Gens Back:</label>
      <input type="number" id="maxGenBackInput" value="5" min="1" max="10">
    </div>
    <div>
      <label for="countBackInput">Count Back:</label>
      <input type="number" id="countBackInput" value="9" min="1" max="20">
    </div>
    <button id="resetBtn">Reset</button>
  </div>

  <!--────────────────────────────────────────────────────────────────────────
    SVG container; we’ll set viewBox dynamically in JS
  ──────────────────────────────────────────────────────────────────────────-->
  <svg id="dagSvg" preserveAspectRatio="xMidYMid meet" viewBox="0 0 1000 700"></svg>

  <!-- Load D3 v7 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    (function () {
      // ─── 1) Dimensions & Pan/Zoom State ───────────────────────────────────────
      let W = window.innerWidth;
      let H = window.innerHeight;
      let halfH = H / 2;

      // Horizontal spacing between columns (MUST be defined right here!)
      const HORIZONTAL_SPACING = 100;

      // Pan/zoom state for auto-scroll
      let scrollX = W / 2;        // world‐x location that’s at the center of the view
      let currentZoom = 1.0;      // current scale (pinch-zoom factor)
      let isPaused = false;       // if we ever decide to pause generation/pan
      let latestBaseX = W / 2;    // the rightmost x used by any block
      let nextX = W / 2;          // x‐coordinate for the next column

      // Block generation parameters
      const DEFAULT_TARGET_BPS = 10;
      let TARGET_AVG_BPS = DEFAULT_TARGET_BPS;
      const BURST_FLUCT_PERCENT = 0.3;
      const MIN_INTERVAL_MS = 100;
      const MAX_INTERVAL_MS = 5000;
      const MIN_COLUMN_PERCENT = 0.20;
      const MAX_COLUMN_PERCENT = 0.80;

      const REFERENCE_UPPER_MAX_COLUMN_PERCENT = 0.80;
      const REFERENCE_LOWER_MAX_COLUMN_PERCENT = 0.10;
      const MIN_SPREAD_RATIO = 0.25;
      const MAX_SPREAD_RATIO = 1.0;
      let normalizedMCP = (MAX_COLUMN_PERCENT - REFERENCE_LOWER_MAX_COLUMN_PERCENT) /
        (REFERENCE_UPPER_MAX_COLUMN_PERCENT - REFERENCE_LOWER_MAX_COLUMN_PERCENT);
      normalizedMCP = Math.max(0, Math.min(1, normalizedMCP));
      const DYNAMIC_VERTICAL_SPREAD_RATIO = MIN_SPREAD_RATIO +
        normalizedMCP * (MAX_SPREAD_RATIO - MIN_SPREAD_RATIO);

      // ─── ADDITIONAL PARAMETERS FOR BACKFILL CONTROL ────────────────────────────
      // How many columns back we may push blocks, and how many blocks max to backfill
      let MAX_GENERATIONS_BACK = 2;  // allow backfill into up to 2 columns back
      let COUNT_BACK = 3;            // allow up to 3 blocks to be backfilled

      // Block size / collision parameters
      const BLOCK_W = 8, BLOCK_H = 8;
      const halfBlockW = BLOCK_W / 2, halfBlockH = BLOCK_H / 2;
      const MIN_SEP = 3;
      const PREFERRED_MAX_BLOCK_CENTER_SPACING_Y = BLOCK_H * 4.0;
      const RECENT_POOL = 12;
      const MAX_X_JITTER = 48;
      const MAX_Y_JITTER = 36;
      const COLLISION_ITERS = 50;
      const COLLISION_STEP = 0.5;
      const CHECK_W = BLOCK_W + MIN_SEP;
      const CHECK_H = BLOCK_H + MIN_SEP;
      const MAX_BURST_JITTER = 200;

      // Core data structures
      let nodes = [];
      let links = [];
      let nodeCounter = 0;
      const columnMap = new Map();
      let tipSet = [];
      const MAX_TIPS = 5;

      // BPS calculation
      let blockQueue = [];
      let blocksInWindow = 0;
      const BPS_WINDOW = 3000;

      // ─── 2) Create SVG, Title, Grid, Groups ───────────────────────────────────
      const svg = d3.select("#dagSvg")
        // Immediately set viewBox so that “0 0 W H” is our coordinate system
        .attr("viewBox", `0 0 ${W} ${H}`);

      // Main group for everything (grid + links + nodes)
      const g = svg.append("g");

      // Draw the grid pattern in a <defs>
      const defs = svg.append("defs");
      const GRID_SMALL = 20, GRID_LARGE_INT = 5, GRID_LARGE = GRID_SMALL * GRID_LARGE_INT;

      const gridPattern = defs.append("pattern")
        .attr("id", "gridPattern")
        .attr("width", GRID_LARGE)
        .attr("height", GRID_LARGE)
        .attr("patternUnits", "userSpaceOnUse");

      // Minor grid lines
      for (let i = 1; i < GRID_LARGE_INT; i++) {
        const pos = i * GRID_SMALL;
        gridPattern.append("line")
          .attr("x1", pos).attr("y1", 0)
          .attr("x2", pos).attr("y2", GRID_LARGE)
          .attr("stroke", "#333")
          .attr("stroke-width", 0.5);
        gridPattern.append("line")
          .attr("x1", 0).attr("y1", pos)
          .attr("x2", GRID_LARGE).attr("y2", pos)
          .attr("stroke", "#333")
          .attr("stroke-width", 0.5);
      }

      // Major grid lines
      gridPattern.append("path")
        .attr("d", `M 0 0 L ${GRID_LARGE} 0`)
        .attr("stroke", "#555")
        .attr("stroke-width", 1);
      gridPattern.append("path")
        .attr("d", `M 0 0 L 0 ${GRID_LARGE}`)
        .attr("stroke", "#555")
        .attr("stroke-width", 1);

      // The rectangle that actually tiles the grid behind everything
      let gridRect = g.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        // **Start with exactly one column’s width**; we’ll expand it as blocks grow.
        .attr("width", HORIZONTAL_SPACING)
        .attr("height", H)
        .attr("fill", "url(#gridPattern)");

      // Title text (always at least y=20px, or H/25 if that is larger)
      const titleText = svg.append("text")
        .attr("class", "title-text")
        .attr("x", W / 2)
        .attr("y", Math.max(20, H / 25))
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr("font-family", "sans-serif")
        .attr("font-size", "40px")
        .attr("font-weight", "bold")
        .attr("fill", "#ff0000")
        .attr("opacity", 0.5)
        .style("pointer-events", "none")
        .text("BLOCKDAG SIMULATION");

      // Groups for links and nodes
      const linkG = g.append("g");
      const nodeG = g.append("g");

      // ─── 3) Helper Functions ─────────────────────────────────────────────────────
      function clamp(v, min, max) {
        return v < min ? min : (v > max ? max : v);
      }
      function randBetween(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomJitter(amount) {
        return randBetween(-amount, amount);
      }
      function linkPath(sx, sy, tx, ty) {
        const mx = (sx + tx) / 2;
        const curveH = Math.max(20, Math.abs(sy - ty) * 0.2 + 20);
        const my = Math.min(sy, ty) - curveH;
        return `M${sx},${sy} Q${mx},${my} ${tx},${ty}`;
      }
      function computeLinkPath(d) {
        return linkPath(d.source.x, d.source.y, d.target.x, d.target.y);
      }
      function getRecentNodes() {
        return nodes.slice(-RECENT_POOL);
      }
      function attachParents(node) {
        if (tipSet.length === 0) {
          tipSet.push(node);
          return;
        }
        const recentWindow = nodes.slice(-10);
        const uniqueCandidates = Array.from(new Set(recentWindow.concat(tipSet)));
        const maxParents = Math.min(uniqueCandidates.length, 3);
        const numParents = Math.max(1, Math.floor(randBetween(1, maxParents + 1)));
        const chosenParents = d3.shuffle(uniqueCandidates.slice()).slice(0, numParents);
        chosenParents.forEach(parentNode => {
          links.push({ source: node, target: parentNode });
        });
        tipSet.push(node);
        if (tipSet.length > MAX_TIPS) tipSet.shift();
      }
      function computeEvenYs(k) {
        if (k === 0) return [];
        const screenCenterY = H / 2;
        if (k === 1) return [screenCenterY];
        const fullSpan = Math.max(0, H - 2 * 10 - BLOCK_H); // VERTICAL_MARGIN = 10
        const allowedSpan = fullSpan * DYNAMIC_VERTICAL_SPREAD_RATIO;
        const spacingIfFull = (k > 1) ? allowedSpan / (k - 1) : allowedSpan;
        let centerSpacing = Math.min(spacingIfFull, PREFERRED_MAX_BLOCK_CENTER_SPACING_Y);
        const minCenter = BLOCK_H + MIN_SEP;
        centerSpacing = Math.max(centerSpacing, minCenter);
        const totalSpan = (k - 1) * centerSpacing;
        const firstY = screenCenterY - totalSpan / 2;
        return Array.from({ length: k }, (_, i) => firstY + i * centerSpacing);
      }
      function resolveCollisions(nodesInCol, centerX) {
        if (nodesInCol.length < 2) return;
        const xMin = centerX - MAX_X_JITTER, xMax = centerX + MAX_X_JITTER;
        const yMin = 10 + halfBlockH, yMax = H - 10 - halfBlockH; // VERTICAL_MARGIN=10
        for (let iter = 0; iter < COLLISION_ITERS; iter++) {
          let anyCollision = false;
          const qt = d3.quadtree()
            .x(d => d.x)
            .y(d => d.y)
            .addAll(nodesInCol);
          nodesInCol.forEach(node => {
            const x0 = node.x - CHECK_W, y0 = node.y - CHECK_H;
            const x1 = node.x + CHECK_W, y1 = node.y + CHECK_H;
            qt.visit((quad, x2, y2, x3, y3) => {
              if (x2 > x1 || y2 > y1 || x3 < x0 || y3 < y0) return true;
              if (!quad.length) {
                const other = quad.data;
                if (other !== node) {
                  const dx = node.x - other.x;
                  const dy = node.y - other.y;
                  if (Math.abs(dx) < CHECK_W && Math.abs(dy) < CHECK_H) {
                    anyCollision = true;
                    const dist = Math.hypot(dx, dy) || 1e-3;
                    const overlapX = (CHECK_W - Math.abs(dx)) / dist;
                    const overlapY = (CHECK_H - Math.abs(dy)) / dist;
                    node.x += dx * COLLISION_STEP * overlapX;
                    node.y += dy * COLLISION_STEP * overlapY;
                    other.x -= dx * COLLISION_STEP * overlapX;
                    other.y -= dy * COLLISION_STEP * overlapY;
                    node.x = clamp(node.x, xMin, xMax);
                    node.y = clamp(node.y, yMin, yMax);
                    other.x = clamp(other.x, xMin, xMax);
                    other.y = clamp(other.y, yMin, yMax);
                  }
                }
              }
              return false;
            });
          });
          if (!anyCollision) break;
        }
      }
      function pruneOffscreen() {
        if (!nodes.length) return;
        // Calculate left‐edge in “world” coords:
        const leftWorld = scrollX - (W / 2) / currentZoom;
        // Remove anything with x < leftWorld - buffer:
        const cutoffX = leftWorld - (W / 1) / currentZoom;
        const survivors = nodes.filter(d => d.x >= cutoffX);
        if (survivors.length === nodes.length) return;
        const liveIds = new Set(survivors.map(n => n.id));
        nodes = survivors;
        links = links.filter(l => liveIds.has(l.source.id) && liveIds.has(l.target.id));
        tipSet = tipSet.filter(n => liveIds.has(n.id));
        nodeG.selectAll("g.node-group").filter(d => !liveIds.has(d.id)).remove();
        linkG.selectAll("path.link")
          .filter(d => !liveIds.has(d.source.id) || !liveIds.has(d.target.id))
          .remove();
      }

      // ─── 4) BPS Calculation ─────────────────────────────────────────────────────
      function recordNewBlocks(count) {
        const ts = Date.now();
        blockQueue.push({ ts, count });
        blocksInWindow += count;
        pruneOldBlockQueue();
      }
      function pruneOldBlockQueue() {
        const cutoffTime = Date.now() - BPS_WINDOW;
        while (blockQueue.length && blockQueue[0].ts < cutoffTime) {
          blocksInWindow -= blockQueue[0].count;
          blockQueue.shift();
        }
      }
      function updateRealtimeBPS() {
        pruneOldBlockQueue();
        const currentBps = blocksInWindow / (BPS_WINDOW / 1000);
        document.getElementById("realtimeBPSDisplay").textContent = currentBps.toFixed(1);
      }
      setInterval(updateRealtimeBPS, 1000);

      // ─── 5) addColumn (block generation) ────────────────────────────────────────
      function addColumn(count) {
        if (count < 1) return;
        const doGenBack = (Math.random() < 0.3);
        let level = 1;
        const levelSamplePool = nodes.slice(-RECENT_POOL * 2);
        if (levelSamplePool.length) {
          const pick = d3.shuffle(levelSamplePool.slice()).map(d => d.level || 1);
          level = Math.min(4, d3.max(pick) + 1);
        }

        const colX = nextX;
        latestBaseX = Math.max(latestBaseX, colX);
        nextX += HORIZONTAL_SPACING;

        if (!columnMap.has(colX)) columnMap.set(colX, []);
        let newBlocksAddedThisCall = 0;

        function createBatch(numNew, xVal, targetYs, existingArr = [], isBackfill = false) {
          const batch = [];

          // 1) Create and assign parents for each new node
          for (let i = 0; i < numNew; i++) {
            const y0 = targetYs[i] + randomJitter(MAX_Y_JITTER);
            const node = {
              id: `B${nodeCounter++}`,
              columnX: xVal,
              level,
              x: xVal + randomJitter(MAX_X_JITTER),
              y: clamp(y0, 10 + halfBlockH, H - 10 - halfBlockH) // VERTICAL_MARGIN=10
            };
            attachParents(node);
            nodes.push(node);
            batch.push(node);
          }

          // 2) Resolve collisions (old + new) in column `xVal`
          const combinedInX = existingArr.concat(batch);
          resolveCollisions(combinedInX, xVal);
          if (isBackfill) columnMap.set(xVal, combinedInX);
          else columnMap.get(xVal).push(...batch);
          newBlocksAddedThisCall += batch.length;

          // ─── DRAW NEW NODES & LINKS ───────────────────────────────────────────────
          const nodeJoin = nodeG.selectAll("g.node-group")
            .data(nodes, d => d.id);

          // Only enter the newly created batch
          const enterSel = nodeJoin.enter()
            .filter(d => batch.some(nb => nb.id === d.id))
            .append("g")
            .attr("class", "node-group")
            // Start at vertical center, then animate down to d.y
            .attr("transform", d => `translate(${d.x}, ${H / 2})`)
            .style("opacity", 0);

          // Append a rectangle for each new node
          enterSel.append("rect")
            .attr("x", -halfBlockW)
            .attr("y", -halfBlockH)
            .attr("width", BLOCK_W)
            .attr("height", BLOCK_H)
            .attr("fill", "#6cf");

          //
          // ─── VERY IMPORTANT: calculate the delay *before* any transition
          //
          const calculatedDelay = randBetween(0, MAX_BURST_JITTER);

          // Append the label text (force its opacity to 1 if showText=true,
          // then fade it in over 200ms)
          enterSel.append("text")
            .attr("class", "block-label-text")
            .attr("dy", -halfBlockH - 4)
            .attr("text-anchor", "middle")
            .text(d => d.id)
            .style("opacity", showText ? 1 : 0)
            .transition()
            .delay(calculatedDelay)
            .duration(200)
            .style("opacity", showText ? 1 : 0);

          // Now transition each <g> down to its final y-position and force opacity=1
          enterSel.transition()
            .delay(calculatedDelay)
            .duration(500)
            .attr("transform", d => `translate(${d.x}, ${d.y})`)
            .style("opacity", 1)
            .on("end", function () {
              // In case the transition was interrupted, guarantee opacity=1
              d3.select(this).style("opacity", 1);
            });

          // Draw the new links (only for this batch of new nodes)
          const newLinkData = links.filter(l => batch.some(nb => nb.id === l.source.id));
          const linkJoin = linkG.selectAll("path.link")
            .data(links, d => `${d.source.id}-${d.target.id}`);

          const linkEnter = linkJoin.enter()
            .filter(d => newLinkData.some(nl => nl.source.id === d.source.id && nl.target.id === d.target.id))
            .append("path")
            .attr("class", "link")
            .style("opacity", 0);

          linkEnter.attr("d", d => {
            return linkPath(d.source.x, H / 2, d.target.x, d.target.y);
          });
          linkEnter.transition()
            .delay(calculatedDelay)
            .duration(300)
            .style("opacity", connectionsVisible ? 1 : 0)
            .attrTween("d", function (dLink) {
              const currentPath = d3.select(this).attr("d");
              const finalPath = computeLinkPath(dLink);
              return d3.interpolateString(currentPath, finalPath);
            });

          return batch;
        }

        // ─── NO BACKFILL: put *all* new blocks in this new column ────────────────
        if (!doGenBack) {
          const Ys = computeEvenYs(count);
          createBatch(count, colX, Ys);

        } else {
          //
          // ─── UPDATED BACKFILL LOGIC ────────────────────────────────────────────
          //    • Place at least one block in the new column
          //    • Send the rest (up to COUNT_BACK) backwards
          //
          let actualNewInCurrentCol, backfillCount;

          if (count > COUNT_BACK) {
            // Normal case: leave (count − COUNT_BACK) blocks here,
            // send exactly COUNT_BACK backwards
            actualNewInCurrentCol = count - COUNT_BACK;
            backfillCount = COUNT_BACK;
          } else {
            // If count ≤ COUNT_BACK, force 1 block in this column,
            // send the other (count − 1) backwards
            actualNewInCurrentCol = 1;
            backfillCount = count - 1;
          }

          // (1) Create whatever belongs in the *current* column:
          if (actualNewInCurrentCol > 0) {
            const YsNew = computeEvenYs(actualNewInCurrentCol);
            createBatch(actualNewInCurrentCol, colX, YsNew);
          }

          // (2) Now place the “backfillCount” blocks into an older column:
          if (backfillCount > 0) {
            const backfillNumCols = Math.ceil(randBetween(1, MAX_GENERATIONS_BACK + 1));
            let backfillTargetX = colX - backfillNumCols * HORIZONTAL_SPACING;
            backfillTargetX = Math.max(0, backfillTargetX);

            if (!columnMap.has(backfillTargetX)) {
              columnMap.set(backfillTargetX, []);
            }
            const existingNodesInBackfillCol = columnMap.get(backfillTargetX).slice();
            const newTotalInBackfillCol = existingNodesInBackfillCol.length + backfillCount;
            const YsBackfill = computeEvenYs(newTotalInBackfillCol);

            // Re‐position existing nodes in that older column so everything re‐spaces evenly
            existingNodesInBackfillCol.forEach((n, i) => {
              n.x = n.columnX + randomJitter(MAX_X_JITTER);
              n.y = clamp(
                YsBackfill[i] + randomJitter(MAX_Y_JITTER),
                10 + halfBlockH,
                H - 10 - halfBlockH
              );
            });

            // Create the batch of brand‐new backfill blocks
            const newYsForBackfillBatch = YsBackfill.slice(existingNodesInBackfillCol.length);
            createBatch(backfillCount, backfillTargetX, newYsForBackfillBatch, existingNodesInBackfillCol, true);

            // Animate any “moved” (existing) nodes and force opacity=1
            const movedNodeIds = new Set(existingNodesInBackfillCol.map(d => d.id));
            nodeG.selectAll("g.node-group")
              .filter(d => movedNodeIds.has(d.id))
              .transition()
              .duration(600)
              .attr("transform", d => `translate(${d.x}, ${d.y})`)
              .style("opacity", 1);

            // Animate the updated links for those moved nodes
            linkG.selectAll("path.link")
              .filter(dLink =>
                (movedNodeIds.has(dLink.source.id) && dLink.source.columnX === backfillTargetX) ||
                (movedNodeIds.has(dLink.target.id) && dLink.target.columnX === backfillTargetX)
              )
              .transition()
              .duration(600)
              .attrTween("d", function (dLink) {
                const prevPath = d3.select(this).attr("d");
                const finalPath = computeLinkPath(dLink);
                return d3.interpolateString(prevPath, finalPath);
              });
          }
        }

        // Record how many new blocks we added in this call
        if (newBlocksAddedThisCall > 0) recordNewBlocks(newBlocksAddedThisCall);

        // Expand the gridRect to cover whatever new x-values we need
        gridRect.attr("width", latestBaseX + (W / currentZoom));
      }

      // ─── 6) Scheduler for Block Generation ─────────────────────────────────────
      let nextBurstScheduler = performance.now();
      function computeNextInterval(currentTime) {
        const avgColSizePercent = (MIN_COLUMN_PERCENT + MAX_COLUMN_PERCENT) / 2;
        const maxBlocksPerColAtAvg = Math.max(1, Math.floor(TARGET_AVG_BPS * avgColSizePercent));
        let avgBlocksPerBurst = (maxBlocksPerColAtAvg + 1) / 2;
        avgBlocksPerBurst = Math.max(1, avgBlocksPerBurst);
        let targetBurstsPerSecond = TARGET_AVG_BPS / avgBlocksPerBurst;
        targetBurstsPerSecond = Math.max(targetBurstsPerSecond, 0.01);
        let avgInterval = 1000 / targetBurstsPerSecond;
        avgInterval = clamp(avgInterval, MIN_INTERVAL_MS, MAX_INTERVAL_MS);
        const fluctuation = avgInterval * BURST_FLUCT_PERCENT;
        let minInterval = Math.max(MIN_INTERVAL_MS, avgInterval - fluctuation);
        let maxInterval = Math.min(MAX_INTERVAL_MS, avgInterval + fluctuation);
        if (minInterval >= maxInterval) maxInterval = minInterval + MIN_INTERVAL_MS * 0.1;
        return currentTime + randBetween(minInterval, maxInterval);
      }
      const scheduler = d3.timer(() => {
        const currentTime = performance.now();
        if (!isPaused && currentTime >= nextBurstScheduler && TARGET_AVG_BPS > 0) {
          const frac = randBetween(MIN_COLUMN_PERCENT, MAX_COLUMN_PERCENT);
          const maxBlocksThisRound = Math.max(1, Math.floor(TARGET_AVG_BPS * frac));
          const numBlocksInBurst = Math.floor(Math.random() * maxBlocksThisRound) + 1;
          try {
            addColumn(numBlocksInBurst);
          } catch (e) {
            console.error("Error during addColumn:", e);
            scheduler.stop();
            return;
          }
          nextBurstScheduler = computeNextInterval(currentTime);
          if (isNaN(nextBurstScheduler)) {
            console.error("Scheduler error: nextBurstScheduler is NaN. Stopping.");
            scheduler.stop();
            return;
          }
          // Pause logic if BPS is very low
          const avgColPct = (MIN_COLUMN_PERCENT + MAX_COLUMN_PERCENT) / 2;
          const maxAtAvg = Math.max(1, Math.floor(TARGET_AVG_BPS * avgColPct));
          let avgForPause = (maxAtAvg + 1) / 2;
          avgForPause = Math.max(1, avgForPause);
          let burstsPerSecPause = TARGET_AVG_BPS / avgForPause;
          if (burstsPerSecPause < 0.5 && nodes.length > RECENT_POOL * 3) {
            isPaused = true;
          } else if (isPaused) {
            isPaused = false;
          }
        }
      });

      // ─── 7) D3 Zoom (only changes scale, not translation) ──────────────────────
      const zoomBehavior = d3.zoom()
        .scaleExtent([0.5, 10])
        .on("zoom", (event) => {
          // (i) Grab the new scale k:
          currentZoom = event.transform.k;

          // (ii) Update the HUD’s zoom‐level display:
          document.getElementById("zoomLevelDisplay").textContent = `${currentZoom.toFixed(2)}x`;

          // (iii) ALWAYS re‐draw <g> using our own scrollX + currentZoom
          g.attr(
            "transform",
            `translate(${W / 2}, ${H / 2})
             scale(${currentZoom})
             translate(${-scrollX}, ${-H / 2})`
          );
        });

      // Attach zoomBehavior to the SVG for both mouse-wheel and pinch:
      svg.call(zoomBehavior)
        // (Optional) disable double‐click‐to‐zoom
        .on("dblclick.zoom", null);

      // ─── 8) Auto‐pan / Render Loop ─────────────────────────────────────────────
      d3.timer(() => {
        const currentTime = performance.now();

        // As long as we’re not paused, gently nudge scrollX toward latestBaseX
        if (!isPaused) {
          const diff = latestBaseX - scrollX;
          scrollX += (Math.abs(diff) < 0.1 ? diff : diff * 0.05);
        }

        // ALWAYS re‐draw <g> using our own scrollX + currentZoom
        g.attr(
          "transform",
          `translate(${W / 2}, ${H / 2})
           scale(${currentZoom})
           translate(${-scrollX}, ${-H / 2})`
        );

        pruneOffscreen();
      });

      // ─── 9) Responsive Resize Handler ──────────────────────────────────────────
      function updateDimensions() {
        W = window.innerWidth;
        H = window.innerHeight;
        halfH = H / 2;

        // Update SVG’s viewBox so everything rescales automatically
        svg.attr("viewBox", `0 0 ${W} ${H}`);

        // Reposition the title so it never collides with HUD:
        const titleY = (W <= 480) ? 60 : Math.max(20, H / 25);
        svg.select("text.title-text")
          .attr("x", W / 2)
          .attr("y", titleY);

        // Resize the grid background:
        gridRect
          .attr("height", H)
          .attr("width", latestBaseX + (W / currentZoom));
      }
      window.addEventListener("resize", updateDimensions);

      // ─── 10) HUD Elements & Event Listeners ──────────────────────────────────
      const targetInput = document.getElementById("targetBPSInput");
      const realtimeBPS = document.getElementById("realtimeBPSDisplay");
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomDisplay = document.getElementById("zoomLevelDisplay");
      const resetBtn = document.getElementById("resetBtn");
      const showTextToggle = document.getElementById("showTextToggle");
      const showConnectionsToggle = document.getElementById("showConnectionsToggle");
      const maxGenBackInput = document.getElementById("maxGenBackInput");
      const countBackInput = document.getElementById("countBackInput");
      let showText = true;
      let connectionsVisible = true;

      targetInput.addEventListener("change", e => {
        const val = parseInt(e.target.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 1000) {
          TARGET_AVG_BPS = val;
          if (isPaused && TARGET_AVG_BPS > 0) isPaused = false;
        } else {
          e.target.value = TARGET_AVG_BPS;
        }
      });

      maxGenBackInput.addEventListener("change", e => {
        const v = parseInt(e.target.value, 10);
        if (!isNaN(v) && v >= 1 && v <= 10) {
          MAX_GENERATIONS_BACK = v;
        } else {
          e.target.value = MAX_GENERATIONS_BACK;
        }
      });

      countBackInput.addEventListener("change", e => {
        const v = parseInt(e.target.value, 10);
        if (!isNaN(v) && v >= 1 && v <= 20) {
          COUNT_BACK = v;
        } else {
          e.target.value = COUNT_BACK;
        }
      });

      // Use the SVG element itself for zoom buttons:
      zoomInBtn.addEventListener("click", () => {
        svg.transition()
          .duration(300)
          .call(zoomBehavior.scaleBy, 1.2);
      });
      zoomOutBtn.addEventListener("click", () => {
        svg.transition()
          .duration(300)
          .call(zoomBehavior.scaleBy, 1 / 1.2);
      });

      // ─── Show Text Toggle: force all labels to full opacity when re-enabled ───
      showTextToggle.addEventListener("change", e => {
        showText = e.target.checked;
        svg.classed("show-text", showText);

        if (showText) {
          // Make *all* existing labels fully opaque right away
          svg.selectAll(".block-label-text")
            .style("opacity", 1);
        }
      });

      showConnectionsToggle.addEventListener("change", e => {
        connectionsVisible = e.target.checked;
        linkG.style("display", connectionsVisible ? null : "none");
        if (connectionsVisible) {
          linkG.selectAll("path.link").style("opacity", 1);
        }
      });

      resetBtn.addEventListener("click", resetVis);
      function resetVis() {
        updateDimensions();
        nodes = [];
        links = [];
        blockQueue = [];
        blocksInWindow = 0;
        columnMap.clear();
        nodeCounter = 0;
        tipSet = [];
        nextX = W / 2;
        latestBaseX = W / 2;
        scrollX = W / 2;
        currentZoom = 1.0;
        isPaused = false;

        nodeG.selectAll("g.node-group").remove();
        linkG.selectAll("path.link").remove();

        targetInput.value = TARGET_AVG_BPS = DEFAULT_TARGET_BPS;
        realtimeBPS.textContent = "0.0";
        zoomDisplay.textContent = `${currentZoom.toFixed(2)}x`;

        showTextToggle.checked = true;
        showText = true;
        svg.classed("show-text", true);

        showConnectionsToggle.checked = true;
        connectionsVisible = true;
        linkG.style("display", null);

        // Reset backfill controls to defaults
        maxGenBackInput.value = MAX_GENERATIONS_BACK = 5;
        countBackInput.value = COUNT_BACK = 9;

        // Reset the gridRect to just one column’s width
        gridRect
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", HORIZONTAL_SPACING)
          .attr("height", H);

        scheduleFirstColumn();
      }

      // ─── 11) Start the very first column ──────────────────────────────────────
      zoomDisplay.textContent = `${currentZoom.toFixed(2)}x`;
      svg.classed("show-text", showText);

      function scheduleFirstColumn() {
        const initialCount = Math.max(1, Math.floor(TARGET_AVG_BPS * MIN_COLUMN_PERCENT));
        addColumn(initialCount);
        nextBurstScheduler = performance.now() + 1;
      }
      scheduleFirstColumn();
    })();
  </script>
</body>

</html>
