<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kaspa‐Style BlockDAG (Responsive Title)</title>

  <style>
    /* ──────────────────────────────────────────────────────────────────────────
       Base Styles
    ─────────────────────────────────────────────────────────────────────────── */
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      font-family: sans-serif;
      color: #fff;
      overflow-x: hidden;
      overflow-y: auto; /* Y-scrolling allowed (SVG may exceed viewport) */
    }

    svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Responsive Title Text
    ─────────────────────────────────────────────────────────────────────────── */
    .title-text {
      font-family: sans-serif;
      font-weight: bold;
      fill: #ff0000;
      opacity: 0.5;
      pointer-events: none;
      /* clamp(min, ideal, max): 16px ≤ font-size ≤ 40px, ideal = 8vw */
      font-size: clamp(16px, 8vw, 40px);
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Link (Edge) Styles
    ─────────────────────────────────────────────────────────────────────────── */
    .link {
      stroke: #87CEFA;          /* LightSkyBlue */
      stroke-opacity: 0.7;      /* Slightly translucent */
      stroke-width: 1.5px;      /* Thicker for visibility */
      fill: none;
      stroke-linecap: round;
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Block Label (Text) Styles
    ─────────────────────────────────────────────────────────────────────────── */
    .block-label-text {
      fill: #fff;
      font-size: 9px;
      pointer-events: none;
      opacity: 0;               /* Hidden by default */
      transition: opacity 0.2s; /* Fade in/out */
    }
    /* When 'show-text' class is applied to the SVG, block-label-text becomes visible */
    .show-text .block-label-text {
      opacity: 1;
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Heads-Up Display (HUD) – Controls Bar at Bottom
    ─────────────────────────────────────────────────────────────────────────── */
    #hud {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      font-size: 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      z-index: 100;
    }

    /* Ensure each child (div/span) in HUD is flex-aligned */
    #hud > div,
    #hud > span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Reset default margins on labels, inputs, buttons inside HUD */
    #hud label,
    #hud input,
    #hud button,
    #hud span {
      margin: 0;
      vertical-align: middle;
    }

    /* Numeric inputs: fixed width for consistency */
    #hud input[type="number"] {
      width: 48px;
    }

    /* Checkbox slightly offset */
    #hud input[type="checkbox"] {
      margin-left: 4px;
    }

    /* Reset button styling */
    #resetBtn {
      padding: 6px 10px;
      background-color: #555;
      color: #fff;
      border: 1px solid #777;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    #resetBtn:hover {
      background-color: #666;
    }

    /* General button padding inside HUD */
    #hud button {
      padding: 4px 8px;
      font-size: 12px;
    }

    /* ──────────────────────────────────────────────────────────────────────────
       Responsive Adjustments for Small Screens
    ─────────────────────────────────────────────────────────────────────────── */
    @media (max-width: 480px) {
      #hud {
        padding: 6px 8px;
        font-size: 11px;
        gap: 8px;
      }
      #hud input[type="number"] {
        width: 40px;
      }
      #hud > div,
      #hud > span {
        gap: 4px;
      }
    }
  </style>
</head>

<body>
  <!-- ──────────────────────────────────────────────────────────────────────────
       HUD: Controls pinned to the bottom
       - Target BPS (blocks per second)
       - Realtime BPS display
       - Zoom in/out buttons and current zoom level
       - Toggles for showing text and connections
       - Max Generations Back, Count Back, Max Parents controls
       - Reset button
  ─────────────────────────────────────────────────────────────────────────── -->
  <div id="hud">
    <div>
      <label for="targetBPSInput">Target BPS:</label>
      <input type="number" id="targetBPSInput" value="10" min="1" max="500" step="1">
    </div>
    <span>
      Realtime BPS: <span id="realtimeBPSDisplay">0.0</span>
    </span>
    <div>
      <label>Zoom:</label>
      <button id="zoomOutBtn">−</button>
      <span id="zoomLevelDisplay">1.00x</span>
      <button id="zoomInBtn">+</button>
    </div>
    <div>
      <input type="checkbox" id="showTextToggle" checked>
      <label for="showTextToggle">Show Text</label>
    </div>
    <div>
      <input type="checkbox" id="showConnectionsToggle" checked>
      <label for="showConnectionsToggle">Show Connections</label>
    </div>
    <div>
      <label for="maxGenBackInput">Max Gens Back:</label>
      <input type="number" id="maxGenBackInput" value="5" min="1" max="10">
    </div>
    <div>
      <label for="countBackInput">Count Back:</label>
      <input type="number" id="countBackInput" value="9" min="1" max="20">
    </div>
    <div>
      <label for="maxParentsInput">Max Parents:</label>
      <input type="number" id="maxParentsInput" value="3" min="1" max="10">
    </div>
    <button id="resetBtn">Reset</button>
  </div>

  <!-- ──────────────────────────────────────────────────────────────────────────
       SVG container for BlockDAG visualization
       - viewBox is set dynamically in JS based on window size
       - preserveAspectRatio ensures responsive scaling
  ─────────────────────────────────────────────────────────────────────────── -->
  <svg id="dagSvg" preserveAspectRatio="xMidYMid meet" viewBox="0 0 1000 700"></svg>

  <!-- Load D3.js v7 from CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    (function() {
      // ──────────────────────────────────────────────────────────────────────────
      // 1) Dimensions & Pan/Zoom State
      // ──────────────────────────────────────────────────────────────────────────
      let W = window.innerWidth;         // Current viewport width
      let H = window.innerHeight;        // Current viewport height
      let halfH = H / 2;                 // Half of viewport height

      // Horizontal spacing between columns of blocks
      const HORIZONTAL_SPACING = 100;

      // Pan/zoom and auto-scroll state variables
      let scrollX = W / 2;               // World‐x at center of view
      let currentZoom = 1.0;             // Current zoom scale
      let isPaused = false;              // Pause flag for generation/pan
      let latestBaseX = W / 2;           // Rightmost x used by any block
      let nextX = W / 2;                 // x-coordinate for next column

      // Block generation parameters
      const DEFAULT_TARGET_BPS = 10;
      let TARGET_AVG_BPS = DEFAULT_TARGET_BPS;
      const BURST_FLUCT_PERCENT = 0.3;    // ±30% fluctuation in burst timing
      const MIN_INTERVAL_MS = 100;        // Minimum interval between bursts
      const MAX_INTERVAL_MS = 5000;       // Maximum interval between bursts
      const MIN_COLUMN_PERCENT = 0.20;    // Minimum % of TARGET_AVG_BPS in a column
      const MAX_COLUMN_PERCENT = 0.80;    // Maximum % of TARGET_AVG_BPS in a column

      // Used to compute dynamic vertical spread ratio based on MAX_COLUMN_PERCENT
      const REFERENCE_UPPER_MAX_COLUMN_PERCENT = 0.80;
      const REFERENCE_LOWER_MAX_COLUMN_PERCENT = 0.10;
      const MIN_SPREAD_RATIO = 0.25;
      const MAX_SPREAD_RATIO = 1.0;
      let normalizedMCP = (MAX_COLUMN_PERCENT - REFERENCE_LOWER_MAX_COLUMN_PERCENT) /
        (REFERENCE_UPPER_MAX_COLUMN_PERCENT - REFERENCE_LOWER_MAX_COLUMN_PERCENT);
      normalizedMCP = Math.max(0, Math.min(1, normalizedMCP));
      const DYNAMIC_VERTICAL_SPREAD_RATIO = MIN_SPREAD_RATIO +
        normalizedMCP * (MAX_SPREAD_RATIO - MIN_SPREAD_RATIO);

      // Backfill control parameters (from HUD)
      let MAX_GENERATIONS_BACK = 5;
      let COUNT_BACK = 9;

      // Block size and collision parameters
      const BLOCK_W = 8, BLOCK_H = 8;                     // Block dimensions
      const halfBlockW = BLOCK_W / 2, halfBlockH = BLOCK_H / 2;
      const MIN_SEP = 3;                                  // Minimum separation after collision
      const VERTICAL_MARGIN = 10;                         // Margin from top/bottom
      const MIN_VERTICAL_CENTER_SPACING = BLOCK_H + MIN_SEP * 2;
      const PREFERRED_MAX_BLOCK_CENTER_SPACING_Y = BLOCK_H * 4.0;

      const RECENT_POOL = 12;                             // Pool size for parent selection
      const MAX_X_JITTER = 48;                            // Horizontal jitter when placing blocks
      const MAX_Y_JITTER = 36;                            // Vertical jitter when placing blocks
      const COLLISION_ITERS = 50;                         // Number of collision-resolution iterations
      const COLLISION_STEP = 0.5;                         // Step size in collision resolution
      const CHECK_W = BLOCK_W + MIN_SEP;                  // Width used for collision detection
      const CHECK_H = BLOCK_H + MIN_SEP;                  // Height used for collision detection
      const MAX_BURST_JITTER = 200;                       // Max random delay before animating

      let MAX_PARENTS_PER_BLOCK = 3;                      // Max parents per new block

      // Core data structures
      let nodes = [];                                     // All block nodes
      let links = [];                                     // All links (edges)
      let nodeCounter = 0;                                // Unique ID counter for blocks
      const columnMap = new Map();                        // Map: columnX → [nodes in that column]
      let tipSet = new Set();                             // Set of “tip” nodes (latest blocks)
      const MAX_TIPS = 5;                                 // (Unused) cap for tipSet size

      // BPS calculation data
      let blockQueue = [];                                // Queue of {ts, count} for recent blocks
      let blocksInWindow = 0;                             // Total blocks in the last BPS_WINDOW ms
      const BPS_WINDOW = 3000;                            // 3 seconds sliding window

      // ──────────────────────────────────────────────────────────────────────────
      // 2) Create SVG Elements: Grid, Title, Groups
      // ──────────────────────────────────────────────────────────────────────────
      const svg = d3.select("#dagSvg")
        .attr("viewBox", `0 0 ${W} ${H}`);
      const g = svg.append("g");      // Container for all dynamic elements
      const defs = svg.append("defs"); // Definitions for patterns, etc.

      // Grid definitions
      const GRID_SMALL = 20;
      const GRID_LARGE_INT = 5;
      const GRID_LARGE = GRID_SMALL * GRID_LARGE_INT;

      // Define a repeating grid pattern
      const gridPattern = defs.append("pattern")
        .attr("id", "gridPattern")
        .attr("width", GRID_LARGE)
        .attr("height", GRID_LARGE)
        .attr("patternUnits", "userSpaceOnUse");

      // Draw the grid lines inside the pattern
      for (let i = 1; i < GRID_LARGE_INT; i++) {
        const pos = i * GRID_SMALL;
        gridPattern.append("line")
          .attr("x1", pos).attr("y1", 0)
          .attr("x2", pos).attr("y2", GRID_LARGE)
          .attr("stroke", "#333")
          .attr("stroke-width", 0.5);

        gridPattern.append("line")
          .attr("x1", 0).attr("y1", pos)
          .attr("x2", GRID_LARGE).attr("y2", pos)
          .attr("stroke", "#333")
          .attr("stroke-width", 0.5);
      }
      // Thicker lines on the top and left edges
      gridPattern.append("path")
        .attr("d", `M 0 0 L ${GRID_LARGE} 0`)
        .attr("stroke", "#555")
        .attr("stroke-width", 1);
      gridPattern.append("path")
        .attr("d", `M 0 0 L 0 ${GRID_LARGE}`)
        .attr("stroke", "#555")
        .attr("stroke-width", 1);

      // Rectangle that uses the grid pattern as fill
      let gridRect = g.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", HORIZONTAL_SPACING)
        .attr("height", H)
        .attr("fill", "url(#gridPattern)");

      // Responsive title text (centered at top)
      const titleText = svg.append("text")
        .attr("class", "title-text")
        .attr("x", W / 2)
        .attr("y", Math.max(20, H / 25))
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .text("BLOCKDAG SIMULATION");

      // Groups for links (edges) and nodes (blocks)
      const linkG = g.append("g");
      const nodeG = g.append("g");

      // ──────────────────────────────────────────────────────────────────────────
      // 3) Helper Functions
      // ──────────────────────────────────────────────────────────────────────────

      /**
       * Clamp a value between min and max.
       */
      function clamp(v, min, max) {
        return v < min ? min : (v > max ? max : v);
      }

      /**
       * Return a random number between [min, max).
       */
      function randBetween(min, max) {
        return Math.random() * (max - min) + min;
      }

      /**
       * Return a random jitter in range [-amount, amount].
       */
      function randomJitter(amount) {
        return randBetween(-amount, amount);
      }

      /**
       * Create a smooth cubic-bezier path between two points.
       * Used to draw edges between blocks.
       */
      function linkPath(sx, sy, tx, ty) {
        const midX = (sx + tx) / 2;
        return `M${sx},${sy}C${midX},${sy},${midX},${ty},${tx},${ty}`;
      }

      /**
       * Given link datum { source, target }, compute its SVG path string.
       */
      function computeLinkPath(d) {
        return linkPath(d.source.x, d.source.y, d.target.x, d.target.y);
      }

      /**
       * Return an array of the most recent RECENT_POOL nodes.
       */
      function getRecentNodes() {
        return nodes.slice(-RECENT_POOL);
      }

      /**
       * Attach parent links to a newly created node.
       * Picks one tip (if available) and possibly additional parents from recent non-tips.
       */
      function attachParents(newNode) {
        const chosenParents = new Set();

        if (tipSet.size > 0) {
          // Convert tipSet to an array and shuffle
          const availableTips = Array.from(tipSet);
          d3.shuffle(availableTips);

          // Always pick at least one tip if possible
          if (availableTips.length > 0) {
            chosenParents.add(availableTips.pop());
          }

          // Prepare a pool of recent non-tip nodes to possibly attach
          let remainingCandidates = availableTips;
          const recentNonTipPoolSize = Math.max(10, TARGET_AVG_BPS * 2);
          const recentNodes = nodes.slice(-recentNonTipPoolSize);
          const recentNonTips = recentNodes.filter(n =>
            n.id !== newNode.id && !tipSet.has(n) && !chosenParents.has(n)
          );

          // Take up to floor(MAX_PARENTS_PER_BLOCK/2) from recent non-tips
          const numToConsider = Math.min(3, Math.floor(MAX_PARENTS_PER_BLOCK / 2));
          const shuffledNonTips = d3.shuffle(recentNonTips).slice(0, numToConsider);
          remainingCandidates = remainingCandidates.concat(shuffledNonTips);

          // Shuffle combined candidates, then pick up to max additional parents
          d3.shuffle(remainingCandidates);
          const maxAdd = MAX_PARENTS_PER_BLOCK - chosenParents.size;
          let added = 0;
          for (const candidate of remainingCandidates) {
            if (added >= maxAdd) break;
            if (candidate.id !== newNode.id && !chosenParents.has(candidate)) {
              chosenParents.add(candidate);
              added++;
            }
          }
        }

        // Create links from newNode to each chosen parent, and update tipSet
        chosenParents.forEach(parent => {
          links.push({ source: newNode, target: parent });
          tipSet.delete(parent);
        });
        tipSet.add(newNode);
      }

      /**
       * Compute evenly spaced Y-coordinates for k blocks in the viewport,
       * centered vertically. Applies dynamic spread ratio, with clamping.
       */
      function computeEvenYs(k) {
        if (k === 0) return [];
        const screenCenterY = H / 2;

        if (k === 1) {
          return [screenCenterY];
        }

        // Compute allowed vertical span based on viewport and spread ratio
        const fullSpan = Math.max(0, H - 2 * VERTICAL_MARGIN - BLOCK_H);
        const allowedSpan = fullSpan * DYNAMIC_VERTICAL_SPREAD_RATIO;

        // Spacing between centers
        let centerSpacing = allowedSpan / (k - 1);
        centerSpacing = Math.max(centerSpacing, MIN_VERTICAL_CENTER_SPACING);
        centerSpacing = Math.min(centerSpacing, PREFERRED_MAX_BLOCK_CENTER_SPACING_Y);

        const totalSpan = (k - 1) * centerSpacing;
        const firstY = screenCenterY - totalSpan / 2;

        return Array.from({ length: k }, (_, i) => firstY + i * centerSpacing);
      }

      /**
       * Resolve collisions among nodes in the same column (x = centerX).
       * Uses a quadtree to iteratively push overlapping blocks apart.
       */
      function resolveCollisions(nodesInCol, centerX) {
        if (nodesInCol.length < 2) return;

        const xMin = centerX - MAX_X_JITTER;
        const xMax = centerX + MAX_X_JITTER;

        // Allow Y to go up to ±2 * H for collision clamping
        const yClampRange = H * 2;
        const yMinClamp = (H / 2) - yClampRange;
        const yMaxClamp = (H / 2) + yClampRange;

        for (let iter = 0; iter < COLLISION_ITERS; iter++) {
          let anyCollision = false;
          const qt = d3.quadtree()
            .x(d => d.x)
            .y(d => d.y)
            .addAll(nodesInCol);

          nodesInCol.forEach(node => {
            const x0 = node.x - CHECK_W, y0 = node.y - CHECK_H;
            const x1 = node.x + CHECK_W, y1 = node.y + CHECK_H;

            qt.visit((quad, x2, y2, x3, y3) => {
              if (x2 > x1 || y2 > y1 || x3 < x0 || y3 < y0) {
                return true;
              }
              if (!quad.length) {
                const other = quad.data;
                if (other !== node) {
                  const dx = node.x - other.x;
                  const dy = node.y - other.y;
                  if (Math.abs(dx) < CHECK_W && Math.abs(dy) < CHECK_H) {
                    anyCollision = true;
                    const dist = Math.hypot(dx, dy) || 1e-3;
                    const overlapX = (CHECK_W - Math.abs(dx)) / dist;
                    const overlapY = (CHECK_H - Math.abs(dy)) / dist;

                    node.x += dx * COLLISION_STEP * overlapX;
                    node.y += dy * COLLISION_STEP * overlapY;
                    other.x -= dx * COLLISION_STEP * overlapX;
                    other.y -= dy * COLLISION_STEP * overlapY;

                    // Clamp positions within allowed jitter range
                    node.x = clamp(node.x, xMin, xMax);
                    node.y = clamp(node.y, yMinClamp, yMaxClamp);
                    other.x = clamp(other.x, xMin, xMax);
                    other.y = clamp(other.y, yMinClamp, yMaxClamp);
                  }
                }
              }
              return false;
            });
          });

          if (!anyCollision) break;
        }
      }

      /**
       * Remove offscreen nodes and their corresponding links/tips.
       * Offscreen threshold is one viewport-width to the left of the visible area.
       */
      function pruneOffscreen() {
        if (!nodes.length) return;

        // Compute left boundary in world coordinates
        const leftWorld = scrollX - (W / 2) / currentZoom;
        const cutoffX = leftWorld - (W / currentZoom);

        // Keep only nodes with x >= cutoffX
        const survivors = nodes.filter(d => d.x >= cutoffX);
        if (survivors.length === nodes.length) return;

        const liveIds = new Set(survivors.map(n => n.id));
        nodes = survivors;

        // Filter links to only those whose source & target still exist
        links = links.filter(l => liveIds.has(l.source.id) && liveIds.has(l.target.id));

        // Update tipSet to only include surviving tips
        const newTipSet = new Set();
        tipSet.forEach(tip => {
          if (liveIds.has(tip.id)) newTipSet.add(tip);
        });
        tipSet = newTipSet;

        // Remove DOM elements of pruned nodes & links
        nodeG.selectAll("g.node-group")
          .filter(d => !liveIds.has(d.id))
          .remove();

        linkG.selectAll("path.link")
          .filter(d => !liveIds.has(d.source.id) || !liveIds.has(d.target.id))
          .remove();
      }

      // ──────────────────────────────────────────────────────────────────────────
      // 4) BPS (Blocks Per Second) Calculation
      // ──────────────────────────────────────────────────────────────────────────

      /**
       * Record that 'count' new blocks were added at timestamp 'ts'.
       * Maintains a sliding window of block counts for BPS calculation.
       */
      function recordNewBlocks(count) {
        const ts = Date.now();
        blockQueue.push({ ts, count });
        blocksInWindow += count;
        pruneOldBlockQueue();
      }

      /**
       * Remove old entries from blockQueue older than BPS_WINDOW ms.
       */
      function pruneOldBlockQueue() {
        const cutoffTime = Date.now() - BPS_WINDOW;
        while (blockQueue.length && blockQueue[0].ts < cutoffTime) {
          blocksInWindow -= blockQueue[0].count;
          blockQueue.shift();
        }
      }

      /**
       * Update the displayed realtime BPS (blocks per second).
       * Called every second via setInterval.
       */
      function updateRealtimeBPS() {
        pruneOldBlockQueue();
        const currentBps = blocksInWindow / (BPS_WINDOW / 1000);
        document.getElementById("realtimeBPSDisplay").textContent = currentBps.toFixed(1);
      }
      setInterval(updateRealtimeBPS, 1000);

      // ──────────────────────────────────────────────────────────────────────────
      // 5) addColumn: Generate a new column of blocks (possibly with backfill)
      // ──────────────────────────────────────────────────────────────────────────

      /**
       * Add one column with 'count' new blocks. Occasionally performs backfill
       * into previous columns.
       */
      function addColumn(count) {
        if (count < 1) return;

        // 30% chance to do backfill instead of normal new column
        const doGenBack = Math.random() < 0.3;

        // Determine block “level” based on recent nodes (used for color/logic later)
        let level = 1;
        const levelSamplePool = nodes.slice(-RECENT_POOL * 2);
        if (levelSamplePool.length) {
          const pick = d3.shuffle(levelSamplePool.slice()).map(d => d.level || 1);
          level = Math.min(4, d3.max(pick) + 1);
        }

        const colX = nextX;
        latestBaseX = Math.max(latestBaseX, colX);
        nextX += HORIZONTAL_SPACING;

        if (!columnMap.has(colX)) {
          columnMap.set(colX, []);
        }

        let newBlocksAddedThisCall = 0;

        /**
         * Internal helper to create a batch of 'numNew' blocks at xVal across targetYs.
         * If isBackfill = true, merges with existingArr (existing nodes in that column).
         */
        function createBatch(numNew, xVal, targetYs, existingArr = [], isBackfill = false) {
          const batch = [];

          // Create new node objects with jittered x/y
          for (let i = 0; i < numNew; i++) {
            const y0 = targetYs[i] + randomJitter(MAX_Y_JITTER);
            const node = {
              id: `B${nodeCounter++}`,
              columnX: xVal,
              level,
              x: xVal + randomJitter(MAX_X_JITTER),
              y: y0
            };
            attachParents(node);
            nodes.push(node);
            batch.push(node);
          }

          // Combine existing nodes (if backfill) with new batch, then resolve collisions
          const combined = existingArr.concat(batch);
          resolveCollisions(combined, xVal);

          // Update columnMap accordingly
          if (isBackfill) {
            columnMap.set(xVal, combined);
          } else {
            columnMap.get(xVal).push(...batch);
          }

          newBlocksAddedThisCall += batch.length;

          // Bind data to node DOM elements
          const nodeJoin = nodeG.selectAll("g.node-group")
            .data(nodes, d => d.id);

          // Append new <g> for each new node in batch
          const enterSel = nodeJoin.enter()
            .filter(d => batch.some(nb => nb.id === d.id))
            .append("g")
              .attr("class", "node-group")
              .attr("transform", d => `translate(${d.x}, ${H / 2})`)
              .style("opacity", 0);

          // Append a rectangle to represent the block
          enterSel.append("rect")
            .attr("x", -halfBlockW)
            .attr("y", -halfBlockH)
            .attr("width", BLOCK_W)
            .attr("height", BLOCK_H)
            .attr("fill", "#6cf");

          // Append text label for the block (initially hidden if showText = false)
          const calculatedDelay = randBetween(0, MAX_BURST_JITTER);
          enterSel.append("text")
            .attr("class", "block-label-text")
            .attr("dy", -halfBlockH - 4)
            .attr("text-anchor", "middle")
            .text(d => d.id)
            .style("opacity", showText ? 1 : 0)
            .transition()
              .delay(calculatedDelay)
              .duration(200)
              .style("opacity", showText ? 1 : 0);

          // Animate new blocks from y = H/2 up to their actual y-position
          enterSel.transition()
            .delay(calculatedDelay)
            .duration(500)
            .attr("transform", d => `translate(${d.x}, ${d.y})`)
            .style("opacity", 1)
            .on("end", function() {
              d3.select(this).style("opacity", 1);
            });

          // Bind data to link DOM elements (edges)
          const newLinkData = links.filter(l => batch.some(nb => nb.id === l.source.id));
          const linkJoin = linkG.selectAll("path.link")
            .data(links, d => `${d.source.id}-${d.target.id}`);

          // Append new <path> for each new edge
          const linkEnter = linkJoin.enter()
            .filter(d => newLinkData.some(nl => nl.source.id === d.source.id && nl.target.id === d.target.id))
            .append("path")
              .attr("class", "link")
              .style("opacity", 0);

          // Set initial path from block’s x at y=H/2 to parent’s (x, y)
          linkEnter
            .attr("d", d => linkPath(d.source.x, H / 2, d.target.x, d.target.y))
            .transition()
              .delay(calculatedDelay)
              .duration(300)
              .style("opacity", connectionsVisible ? 1 : 0)
              .attrTween("d", function(dLink) {
                const prevPath = d3.select(this).attr("d");
                const finalPath = computeLinkPath(dLink);
                return d3.interpolateString(prevPath, finalPath);
              });

          return batch;
        }

        // ─────────────── Normal column creation (no backfill) ───────────────
        if (!doGenBack) {
          const Ys = computeEvenYs(count);
          createBatch(count, colX, Ys);
        }
        // ─────────────── Column creation with backfill ───────────────────────
        else {
          let actualNew = 1, backfillCount = 0;

          if (count > COUNT_BACK) {
            actualNew = count - COUNT_BACK;
            backfillCount = COUNT_BACK;
          } else {
            actualNew = 1;
            backfillCount = count - 1;
          }

          // Create new blocks in the current column
          if (actualNew > 0) {
            const YsNew = computeEvenYs(actualNew);
            createBatch(actualNew, colX, YsNew);
          }

          // Perform backfill if needed
          if (backfillCount > 0) {
            // Choose a random number of columns to backfill (1 to MAX_GENERATIONS_BACK)
            const backfillCols = Math.ceil(randBetween(1, MAX_GENERATIONS_BACK + 1));
            let backfillX = colX - backfillCols * HORIZONTAL_SPACING;
            backfillX = Math.max(0, backfillX);

            if (!columnMap.has(backfillX)) {
              columnMap.set(backfillX, []);
            }

            // Existing nodes in the backfill column
            const existingInBackfill = columnMap.get(backfillX).slice();
            const newTotal = existingInBackfill.length + backfillCount;
            const YsBackfill = computeEvenYs(newTotal);

            // Reposition existing nodes within that column
            existingInBackfill.forEach((n, i) => {
              n.x = n.columnX + randomJitter(MAX_X_JITTER);
              n.y = YsBackfill[i] + randomJitter(MAX_Y_JITTER);
            });

            // Create new nodes that fill up the rest of that column
            const newYs = YsBackfill.slice(existingInBackfill.length);
            createBatch(backfillCount, backfillX, newYs, existingInBackfill, true);

            // Animate repositioned existing nodes in that column
            const movedIds = new Set(existingInBackfill.map(d => d.id));
            nodeG.selectAll("g.node-group")
              .filter(d => movedIds.has(d.id))
              .transition()
                .duration(600)
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .style("opacity", 1);

            // Animate affected links in that column
            linkG.selectAll("path.link")
              .filter(dLink =>
                (movedIds.has(dLink.source.id) && dLink.source.columnX === backfillX) ||
                (movedIds.has(dLink.target.id) && dLink.target.columnX === backfillX)
              )
              .transition()
                .duration(600)
                .attrTween("d", function(dLink) {
                  const prev = d3.select(this).attr("d");
                  const final = computeLinkPath(dLink);
                  return d3.interpolateString(prev, final);
                });
          }
        }

        // Record newly added blocks for BPS calculation
        if (newBlocksAddedThisCall > 0) {
          recordNewBlocks(newBlocksAddedThisCall);
        }

        // Expand grid width if necessary
        gridRect.attr("width", latestBaseX + (W / currentZoom));
      }

      // ──────────────────────────────────────────────────────────────────────────
      // 6) Scheduler for Block Generation (Bursts)
      // ──────────────────────────────────────────────────────────────────────────

      let nextBurstScheduler = performance.now();

      /**
       * Compute the next timestamp (performance.now()) at which to trigger a new burst.
       * Uses TARGET_AVG_BPS, MIN_COLUMN_PERCENT, MAX_COLUMN_PERCENT, and burst fluctuation.
       */
      function computeNextInterval(currentTime) {
        // Average column size (in blocks) at the midpoint of min/max percentage
        const avgColSizePercent = (MIN_COLUMN_PERCENT + MAX_COLUMN_PERCENT) / 2;
        const maxBlocksAtAvg = Math.max(1, Math.floor(TARGET_AVG_BPS * avgColSizePercent));
        let avgBlocksPerBurst = (maxBlocksAtAvg + 1) / 2;
        avgBlocksPerBurst = Math.max(1, avgBlocksPerBurst);

        // Target bursts per second
        let targetBurstsPerSecond = TARGET_AVG_BPS / avgBlocksPerBurst;
        targetBurstsPerSecond = Math.max(targetBurstsPerSecond, 0.01);

        // Compute average interval in ms
        let avgInterval = 1000 / targetBurstsPerSecond;
        avgInterval = clamp(avgInterval, MIN_INTERVAL_MS, MAX_INTERVAL_MS);

        // Apply ± BURST_FLUCT_PERCENT
        const fluctuation = avgInterval * BURST_FLUCT_PERCENT;
        let minInterval = Math.max(MIN_INTERVAL_MS, avgInterval - fluctuation);
        let maxInterval = Math.min(MAX_INTERVAL_MS, avgInterval + fluctuation);

        if (minInterval >= maxInterval) {
          maxInterval = minInterval + MIN_INTERVAL_MS * 0.1;
        }

        return currentTime + randBetween(minInterval, maxInterval);
      }

      // D3 timer loop that schedules new bursts of blocks
      const scheduler = d3.timer(() => {
        const currentTime = performance.now();

        // If not paused and it's time for the next burst
        if (!isPaused && currentTime >= nextBurstScheduler && TARGET_AVG_BPS > 0) {
          // Determine how many blocks to generate in this burst
          const frac = randBetween(MIN_COLUMN_PERCENT, MAX_COLUMN_PERCENT);
          const maxThisRound = Math.max(1, Math.floor(TARGET_AVG_BPS * frac));
          const numBlocksInBurst = Math.floor(Math.random() * maxThisRound) + 1;

          try {
            addColumn(numBlocksInBurst);
          } catch (e) {
            console.error("Error during addColumn:", e);
            scheduler.stop();
            return;
          }

          nextBurstScheduler = computeNextInterval(currentTime);

          if (isNaN(nextBurstScheduler)) {
            console.error("Scheduler error: nextBurstScheduler is NaN. Stopping.");
            scheduler.stop();
            return;
          }

          // Auto-pause logic if generation becomes too sparse
          const avgColPct = (MIN_COLUMN_PERCENT + MAX_COLUMN_PERCENT) / 2;
          const maxAtAvg = Math.max(1, Math.floor(TARGET_AVG_BPS * avgColPct));
          let avgForPause = (maxAtAvg + 1) / 2;
          avgForPause = Math.max(1, avgForPause);
          let burstsPerSecPause = TARGET_AVG_BPS / avgForPause;

          if (burstsPerSecPause < 0.5 && nodes.length > RECENT_POOL * 3) {
            isPaused = true;
          } else if (isPaused) {
            isPaused = false;
          }
        }
      });

      // ──────────────────────────────────────────────────────────────────────────
      // 7) D3 Zoom Behavior (scaling only, no translation reset)
      // ──────────────────────────────────────────────────────────────────────────
      const zoomBehavior = d3.zoom()
        .scaleExtent([0, 10])  // Allow zoom from 0× to 10×
        .on("zoom", (event) => {
          currentZoom = event.transform.k;
          document.getElementById("zoomLevelDisplay").textContent = `${currentZoom.toFixed(2)}x`;
          g.attr("transform",
            `translate(${W / 2}, ${H / 2}) scale(${currentZoom}) translate(${-scrollX}, ${-H / 2})`
          );
        });

      // Attach zoom behavior to SVG (disable dblclick-to-zoom)
      svg.call(zoomBehavior).on("dblclick.zoom", null);

      // ──────────────────────────────────────────────────────────────────────────
      // 8) Auto-pan & Render Loop
      // ──────────────────────────────────────────────────────────────────────────
      d3.timer(() => {
        if (!isPaused) {
          const diff = latestBaseX - scrollX;
          scrollX += (Math.abs(diff) < 0.1 ? diff : diff * 0.05);
        }
        g.attr("transform",
          `translate(${W / 2}, ${H / 2}) scale(${currentZoom}) translate(${-scrollX}, ${-H / 2})`
        );
        pruneOffscreen();
      });

      // ──────────────────────────────────────────────────────────────────────────
      // 9) Responsive Resize Handler
      // ──────────────────────────────────────────────────────────────────────────
      function updateDimensions() {
        W = window.innerWidth;
        H = window.innerHeight;
        halfH = H / 2;
        svg.attr("viewBox", `0 0 ${W} ${H}`);

        // Adjust title Y-position based on viewport size
        const titleY = (W <= 480) ? 60 : Math.max(20, H / 25);
        svg.select("text.title-text")
          .attr("x", W / 2)
          .attr("y", titleY);

        // Expand grid height and width if needed
        gridRect
          .attr("height", H)
          .attr("width", latestBaseX + (W / currentZoom));
      }
      window.addEventListener("resize", updateDimensions);

      // ──────────────────────────────────────────────────────────────────────────
      // 10) HUD Elements & Event Listeners
      // ──────────────────────────────────────────────────────────────────────────
      const targetInput = document.getElementById("targetBPSInput");
      const zoomInBtn = document.getElementById("zoomInBtn");
      const zoomOutBtn = document.getElementById("zoomOutBtn");
      const zoomDisplay = document.getElementById("zoomLevelDisplay");
      const resetBtn = document.getElementById("resetBtn");
      const showTextToggle = document.getElementById("showTextToggle");
      const showConnectionsToggle = document.getElementById("showConnectionsToggle");
      const maxGenBackInput = document.getElementById("maxGenBackInput");
      const countBackInput = document.getElementById("countBackInput");
      const maxParentsInput = document.getElementById("maxParentsInput");

      let showText = true;
      let connectionsVisible = true;

      // Update TARGET_AVG_BPS when user changes input
      targetInput.addEventListener("change", e => {
        const val = parseInt(e.target.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 1000) {
          TARGET_AVG_BPS = val;
          if (isPaused && TARGET_AVG_BPS > 0) {
            isPaused = false;
          }
        } else {
          e.target.value = TARGET_AVG_BPS;
        }
      });

      // Update MAX_GENERATIONS_BACK when changed
      maxGenBackInput.addEventListener("change", e => {
        const v = parseInt(e.target.value, 10);
        if (!isNaN(v) && v >= 1 && v <= 10) {
          MAX_GENERATIONS_BACK = v;
        } else {
          e.target.value = MAX_GENERATIONS_BACK;
        }
      });

      // Initialize and update MAX_PARENTS_PER_BLOCK
      maxParentsInput.value = MAX_PARENTS_PER_BLOCK;
      maxParentsInput.addEventListener("change", e => {
        const val = parseInt(e.target.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 10) {
          MAX_PARENTS_PER_BLOCK = val;
        } else {
          e.target.value = MAX_PARENTS_PER_BLOCK;
        }
      });

      // Update COUNT_BACK when changed
      countBackInput.addEventListener("change", e => {
        const v = parseInt(e.target.value, 10);
        if (!isNaN(v) && v >= 1 && v <= 20) {
          COUNT_BACK = v;
        } else {
          e.target.value = COUNT_BACK;
        }
      });

      // Zoom in/out on button clicks (animated)
      zoomInBtn.addEventListener("click", () => {
        svg.transition().duration(300).call(zoomBehavior.scaleBy, 1.2);
      });
      zoomOutBtn.addEventListener("click", () => {
        svg.transition().duration(300).call(zoomBehavior.scaleBy, 1 / 1.2);
      });

      // Toggle block labels on/off
      showTextToggle.addEventListener("change", e => {
        showText = e.target.checked;
        svg.classed("show-text", showText);
        if (showText) {
          svg.selectAll(".block-label-text").style("opacity", 1);
        }
      });

      // Toggle connections (edges) on/off
      showConnectionsToggle.addEventListener("change", e => {
        connectionsVisible = e.target.checked;
        linkG.style("display", connectionsVisible ? null : "none");
        if (connectionsVisible) {
          linkG.selectAll("path.link").style("opacity", 1);
        }
      });

      // Reset everything to initial state
      resetBtn.addEventListener("click", resetVis);

      function resetVis() {
        // Reset dimensions & state variables
        updateDimensions();
        nodes = [];
        links = [];
        blockQueue = [];
        blocksInWindow = 0;
        columnMap.clear();
        nodeCounter = 0;
        tipSet = new Set();
        nextX = W / 2;
        latestBaseX = W / 2;
        scrollX = W / 2;
        currentZoom = 1.0;
        isPaused = false;

        // Clear all SVG elements
        nodeG.selectAll("g.node-group").remove();
        linkG.selectAll("path.link").remove();

        // Reset HUD inputs and display
        targetInput.value = TARGET_AVG_BPS = DEFAULT_TARGET_BPS;
        document.getElementById("realtimeBPSDisplay").textContent = "0.0";
        zoomDisplay.textContent = `${currentZoom.toFixed(2)}x`;
        showTextToggle.checked = true; showText = true;
        svg.classed("show-text", true);
        showConnectionsToggle.checked = true; connectionsVisible = true;
        linkG.style("display", null);
        maxGenBackInput.value = MAX_GENERATIONS_BACK = 5;
        countBackInput.value = COUNT_BACK = 9;
        maxParentsInput.value = MAX_PARENTS_PER_BLOCK = 3;

        // Reset grid rectangle
        gridRect
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", HORIZONTAL_SPACING)
          .attr("height", H);

        // Schedule the first column after reset
        scheduleFirstColumn();
      }

      // ──────────────────────────────────────────────────────────────────────────
      // 11) Start the First Column on Load
      // ──────────────────────────────────────────────────────────────────────────
      zoomDisplay.textContent = `${currentZoom.toFixed(2)}x`;
      svg.classed("show-text", showText);

      function scheduleFirstColumn() {
        const initialCount = Math.max(1, Math.floor(TARGET_AVG_BPS * MIN_COLUMN_PERCENT));
        addColumn(initialCount);
        nextBurstScheduler = performance.now() + 1;
      }

      scheduleFirstColumn();
    })();
  </script>
</body>

</html>
